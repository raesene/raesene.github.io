<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Raesene's Ramblings</title>
		<description>Things that occur to me</description>
		<link>https://raesene.github.io/</link>
		<atom:link href="https://raesene.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Fun with unicode - messing with output</title>
				<description>&lt;p&gt;This week there was some research published from Cambridge university called “&lt;a href=&quot;https://www.trojansource.codes/&quot;&gt;Trojan Codes&lt;/a&gt;”, around the potential risks of RTL unicode characters in source code. Whilst this is very much not a new problem, there have been various pieces of research over the years about the difficulties of handling unicode characters, it seemed like a good cue to look at this kind of issue in the context of Kubernetes. So far I’ve not found any security issues caused by this, but I found a couple of things which could be of interest, so thought I’d write it down, in case it’s useful to anyone.&lt;/p&gt;

&lt;h2 id=&quot;where-might-this-cause-a-problem&quot;&gt;Where might this cause a problem?&lt;/h2&gt;

&lt;p&gt;So now we’ve looked at this, the question is, where could this cause problems? The obvious answer here is that, if a cluster administrator is relying on the output of kubectl commands to make security decisions, ways of modifying the output could cause security issues. This is similar to &lt;a href=&quot;https://github.com/kubernetes/kubectl/issues/888&quot;&gt;this issue&lt;/a&gt; in how CSR information can be represented.&lt;/p&gt;

&lt;p&gt;Another idea might be whether this could be used to bypass external admission controllers. If the admission controller and Kubernetes parse the information in different ways, that might be a possibility.&lt;/p&gt;

&lt;p&gt;It’s not a problem for the project specifically, but it is something that cluster operators should be aware of.&lt;/p&gt;

&lt;h2 id=&quot;putting-unicode-into-kubernetes-manifests&quot;&gt;Putting unicode into Kubernetes manifests&lt;/h2&gt;

&lt;p&gt;So, how do you actually put RTL style codes into Kubernetes manifests? Essentially the format is something like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;\U0000202E&quot;&lt;/code&gt; and putting these codes in a manifest can will change how the information is stored and displayed by Kubernetes. So a concrete example would look like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRoleBinding&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;roleRef&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;User&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U0000202E&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nimda-retsulc&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U0000202C&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you create that manifest and then retrieve it, you can see that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; in the output shows as cluster-admin with a couple of white spaces in front of it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/rtl-unicode.png&quot; alt=&quot;rtl in manifest&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;other-possible-unicode-fun&quot;&gt;Other possible unicode fun&lt;/h2&gt;

&lt;p&gt;Another area where this kind of thing can cause problems for visual inspection of output is the use of “homoglyph” attacks. It’s possible to insert characters which look like an ASCII one but which are not (for example this may look like аdmin but actually the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; character is a Cryllic character)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The complexities which go with unicode characters are definitely one to be aware of with regards to their possible security impact. There have been multiple cases in the past where security vulnerabilities have occurred due to misinterpretation of UTF-8 input, and I’m sure there will be more in the future :)&lt;/p&gt;
</description>
				<pubDate>Sat, 06 Nov 2021 08:50:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/11/06/fun-with-unicode/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/11/06/fun-with-unicode/</guid>
			</item>
		
			<item>
				<title>Fun with CRDs - Overwriting core types</title>
				<description>&lt;p&gt;I was playing around with CRDs today when I wondered “what would happen if I tried to overwrite one of Kubernetes’ core object types? The results weren’t what I expected, so thought it was worth writing it down, in case it comes as a surprise to others :) &lt;strong&gt;N.B. There’s an update at the bottom which sheds more light on what happens when you do this&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;whats-a-crd&quot;&gt;What’s a CRD?&lt;/h2&gt;

&lt;p&gt;Kubernetes Custom Resources are a way to extend the core Kubernetes API with custom types. They’re heavily used by various programs which extend Kubernetes functionality, and a common feature of most clusters.  In general, Custom Resources have their own group so, for example if you use Cilium for your kubernetes networking, you’ll have CRDs like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ciliumendpoints.cilium.io&lt;/code&gt; which is the ciliumendpoint object in the cilium.io group.&lt;/p&gt;

&lt;h2 id=&quot;overwriting-core-kubernetes-crds&quot;&gt;Overwriting core Kubernetes CRDs&lt;/h2&gt;

&lt;p&gt;So an obvious question for a curious goose is, what happens if I try to create a CRD with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io&lt;/code&gt; group, which is used by a lot of core Kubernetes objects. Well, let’s find out !&lt;/p&gt;

&lt;p&gt;If we write a basic CRD which starts like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apiextensions.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;CustomResourceDefinition&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;networkpolicies.networking.k8s.io&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;we get an error when we create it. The error handily tells us that we need an annotation added to create a CRD in this group&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The CustomResourceDefinition &quot;networkpolicies.networking.k8s.io&quot; is invalid: metadata.annotations[api-approved.kubernetes.io]: Required value: protected groups must have approval annotation &quot;api-approved.kubernetes.io&quot;, see https://github.com/kubernetes/enhancements/pull/1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There’s no validation on the contents of this annotation, so I just took the sample one from the GH issue. After I did that, it works! The first time I created a CRD overwriting the Network Policy object, I had it as a namespace scoped object and the results were unexpected.&lt;/p&gt;

&lt;p&gt;Checking &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get crds&lt;/code&gt; shows that it created ok (The one I created didn’t have an egress field)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get crds
NAME                                CREATED AT
networkpolicies.networking.k8s.io   2021-11-01T19:28:04Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but if I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt; on the object, the definition I get back is the original core object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl explain networkpolicies.networking.k8s.io.spec
KIND:     NetworkPolicy
VERSION:  networking.k8s.io/v1

RESOURCE: spec &amp;lt;Object&amp;gt;

DESCRIPTION:
     Specification of the desired behavior for this NetworkPolicy.

     NetworkPolicySpec provides the specification of a NetworkPolicy

FIELDS:
   egress       &amp;lt;[]Object&amp;gt;
     List of egress rules to be applied to the selected pods. Outgoing traffic
     is allowed if there are no NetworkPolicies selecting the pod (and cluster
     policy otherwise allows the traffic), OR if the traffic matches at least
     one egress rule across all of the NetworkPolicy objects whose podSelector
     matches the pod. If this field is empty then this NetworkPolicy limits all
     outgoing traffic (and serves solely to ensure that the pods it selects are
     isolated by default). This field is beta-level in 1.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also if I try to create a sample network policy which uses the original object type, it works ok. So the CRD is there, but it’s not working.&lt;/p&gt;

&lt;p&gt;What happens if you change the scope in the CRD from namespaced to cluster? Well now, it shows in the CRD list &lt;em&gt;and&lt;/em&gt; it’s overwritten the object definition retrieved by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl explain networkpolicies.networking.k8s.io.spec
KIND:     NetworkPolicy
VERSION:  networking.k8s.io/v1

RESOURCE: spec &amp;lt;Object&amp;gt;

DESCRIPTION:
     &amp;lt;empty&amp;gt;

FIELDS:
   name &amp;lt;string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and if I try to create a Network Policy, I get an error showing that it doesn’t understand those field, so this has overwritten the core object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: error validating &quot;sample-netpol.yaml&quot;: error validating data: [ValidationError(NetworkPolicy.spec): unknown field &quot;egress&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;ingress&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;podSelector&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;policyTypes&quot; in io.k8s.networking.v1.NetworkPolicy.spec]; if you choose to ignore these errors, turn validation off with --validate=false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;other-examples&quot;&gt;Other examples&lt;/h2&gt;

&lt;p&gt;There’s more prodding at this to be done, but a fun additional one I noticed is that if you try to create a CRD with a name of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users.authentication.k8s.io&lt;/code&gt; it creates, but the result isn’t visible in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl api-resources&lt;/code&gt; and you can’t use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt; on it, even though it’s not overwriting a visible Object type.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;From a security standpoint, the takeaway here is, don’t let anyone create CRDs in your cluster unless you really really trust them, &lt;del&gt;as they can modify Kubernetes core behaviour&lt;/del&gt;. Also if you’re planning to appear on Rawkode’s klustered show, you could try this and hope the cluster fixers don’t read my blog :)&lt;/p&gt;

&lt;h2 id=&quot;update-03112021&quot;&gt;Update 03/11/2021&lt;/h2&gt;

&lt;p&gt;Curious to get some details on was going on behind the scenes and possible security implications, I asked on k8s slack (a great source of information), and the inimitable &lt;a href=&quot;https://twitter.com/liggitt&quot;&gt;Jordan Liggitt&lt;/a&gt; was able to explain it. It seems like this doesn’t actually overwrite the core Kubernetes types, but what it does do is modify OpenAPI schemes used by clients like Kubectl to validate data being passed to the API server. So, in effect this could break tooling or produce odd behaviour but isn’t modifying the core Kubernetes API. There’s an issue in the &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/106056&quot;&gt;Kubernetes Github repo&lt;/a&gt; with more info.&lt;/p&gt;

&lt;p&gt;To me, it’s still interesting, but in a slightly different way as it illuminates how some of the different components in Kubernetes work together and some of the possible complexity when unusual or unexpected changes are made.&lt;/p&gt;
</description>
				<pubDate>Mon, 01 Nov 2021 08:50:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/11/01/fun-with-CRDs/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/11/01/fun-with-CRDs/</guid>
			</item>
		
			<item>
				<title>Restricting Docker Access With a Reverse Proxy</title>
				<description>&lt;p&gt;One of the things that comes up a lot with Docker security is that, by default, the authorization model is all or nothing. Essentially any user or process that has access to the Docker socket (or Docker TCP port if it’s configured to listen on a network) can use any of its functions. This means that from a security standpoint essentially any user with Docker access can get root on the host &lt;a href=&quot;https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/&quot;&gt;easily&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is a bit of a problem if you have something like monitoring software, which you want to be able to get stats on running containers, but you don’t really want it to have access to all of Docker’s functionality. So I was wondering, what would be a good way to restrict it, so you can let the monitoring software see the information it needs, without giving it root rights to the host.&lt;/p&gt;

&lt;h2 id=&quot;http-apis-and-reverse-proxies&quot;&gt;HTTP APIs and Reverse Proxies&lt;/h2&gt;

&lt;p&gt;As Docker is essentially an HTTP API, one idea would be to use a reverse proxy to sit in front of it and filter what paths are available. Ideally it would be good to have a proxy that understands unix socket files, so we don’t need to expose Docker on the network to make it work. Luckily a brief bit of searching showed me there were some good options and in particular &lt;a href=&quot;https://caddyserver.com/&quot;&gt;Caddy&lt;/a&gt; looked like it would fit the bill. As an aside the initial version of Caddy I tried (v2.4.3) would hang with some Docker responses but the latest version (v2.4.5) should be fine.&lt;/p&gt;

&lt;p&gt;Before I get into the details, I’ll mention this is just a PoC, I wouldn’t rely on it in production without more work and testing, but the basics work fine :)&lt;/p&gt;

&lt;h2 id=&quot;setting-up-a-docker-reverse-proxy-with-caddy&quot;&gt;Setting up a Docker Reverse Proxy with Caddy&lt;/h2&gt;

&lt;p&gt;After installing Caddy the first thing to do was make sure it worked the way I expected. For that a simple Caddyfile like this one does the trick&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  debug
}


http://localhost:2379 {
  reverse_proxy unix///var/run/docker.sock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will expose a network port of 2379/TCP and just send on any requests to the Docker socket. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debug&lt;/code&gt; stanza at the top just gets Caddy to output verbose information which is handy when working out what’s happening.&lt;/p&gt;

&lt;p&gt;With that in place we can just tell Docker to connect to that port and see if it works using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H&lt;/code&gt; switch&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -H tcp://localhost:2379 info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That works just fine and we can see in the Caddy debug log, the requests going through the proxy to Docker&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2021/09/05 08:37:07.052 DEBUG   http.handlers.reverse_proxy     upstream roundtrip      {&quot;upstream&quot;: &quot;unix///var/run/docker.sock&quot;, &quot;request&quot;: {&quot;remote_addr&quot;: &quot;127.0.0.1:55376&quot;, &quot;proto&quot;: &quot;HTTP/1.1&quot;, &quot;method&quot;: &quot;HEAD&quot;, &quot;host&quot;: &quot;localhost:2379&quot;, &quot;uri&quot;: &quot;/_ping&quot;, &quot;headers&quot;: {&quot;User-Agent&quot;: [&quot;Docker-Client/20.10.8 (linux)&quot;], &quot;X-Forwarded-Proto&quot;: [&quot;http&quot;], &quot;X-Forwarded-For&quot;: [&quot;127.0.0.1&quot;]}}, &quot;headers&quot;: {&quot;Pragma&quot;: [&quot;no-cache&quot;], &quot;Server&quot;: [&quot;Docker/20.10.8 (linux)&quot;], &quot;Date&quot;: [&quot;Sun, 05 Sep 2021 08:37:07 GMT&quot;], &quot;Api-Version&quot;: [&quot;1.41&quot;], &quot;Content-Length&quot;: [&quot;0&quot;], &quot;Content-Type&quot;: [&quot;text/plain; charset=utf-8&quot;], &quot;Cache-Control&quot;: [&quot;no-cache, no-store, must-revalidate&quot;], &quot;Docker-Experimental&quot;: [&quot;false&quot;], &quot;Ostype&quot;: [&quot;linux&quot;]}, &quot;status&quot;: 200}
2021/09/05 08:37:07.067 DEBUG   http.handlers.reverse_proxy     upstream roundtrip      {&quot;upstream&quot;: &quot;unix///var/run/docker.sock&quot;, &quot;request&quot;: {&quot;remote_addr&quot;: &quot;127.0.0.1:55376&quot;, &quot;proto&quot;: &quot;HTTP/1.1&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;host&quot;: &quot;localhost:2379&quot;, &quot;uri&quot;: &quot;/v1.41/info&quot;, &quot;headers&quot;: {&quot;X-Forwarded-For&quot;: [&quot;127.0.0.1&quot;], &quot;User-Agent&quot;: [&quot;Docker-Client/20.10.8 (linux)&quot;], &quot;X-Forwarded-Proto&quot;: [&quot;http&quot;]}}, &quot;headers&quot;: {&quot;Api-Version&quot;: [&quot;1.41&quot;], &quot;Content-Type&quot;: [&quot;application/json&quot;], &quot;Docker-Experimental&quot;: [&quot;false&quot;], &quot;Ostype&quot;: [&quot;linux&quot;], &quot;Server&quot;: [&quot;Docker/20.10.8 (linux)&quot;], &quot;Date&quot;: [&quot;Sun, 05 Sep 2021 08:37:07 GMT&quot;]}, &quot;status&quot;: 200}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This information is useful because it lets us know what paths we need to whitelist for our restrictive proxy. It’s important to try and whitelist the paths you definitely need and not try to blacklist the paths you don’t need, otherwise one missing path could ruin your whole day.&lt;/p&gt;

&lt;p&gt;With that setup in place, we can just run all the Docker commands we want our monitoring software to do and build out a set of paths that should be allowed by the proxy. My set ended up like this.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  debug
}

http://localhost:2379 {
  @infourl {
    method GET
    path /v1.41/info
  }

  @pingurl {
    method HEAD
    path /_ping
  }

  @versionurl {
    method GET
    path /v1.41/version
  }

  @eventsurl {
    method GET
    path /v1.41/events
  }

  @statsurl {
    method GET
    path /v1.41/stats
  }

  @containerstatsurl {
    method GET
    path /v1.41/containers/*/stats
  }

  @containersurl {
    method GET
    path /v1.41/containers/json
  }

  reverse_proxy @pingurl unix///var/run/docker.sock
  reverse_proxy @infourl unix///var/run/docker.sock
  reverse_proxy @versionurl unix///var/run/docker.sock
  reverse_proxy @eventsurl unix///var/run/docker.sock
  reverse_proxy @statsurl unix///var/run/docker.sock
  reverse_proxy @containerstatsurl unix///var/run/docker.sock
  reverse_proxy @containersurl unix///var/run/docker.sock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that set of paths in place, software should be able to gather stats, list Docker engine information and list the running containers.  If the client tries any other operation it just produces an EOF error.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -H tcp://localhost:2379 images
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So this is one option for trying to provide a restricted view of the Docker API for things like monitoring tools. Getting to something production ready would obviously require more work, but the basic concept is interesting.&lt;/p&gt;
</description>
				<pubDate>Sun, 05 Sep 2021 09:50:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/09/05/restricting-docker-access-with-a-proxy/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/09/05/restricting-docker-access-with-a-proxy/</guid>
			</item>
		
			<item>
				<title>Containers and Low Ports</title>
				<description>&lt;p&gt;I had cause to look into unprivileged binding of ports in Docker containers recently, and found a couple of things that were a surprise to me, so taking the time to write them down, in case it’s of use to anyone else.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;Traditionally, on a Linux system, to bind a port lower than 1024 a process either had to be run by the root user, be setUID root or have CAP_NET_BIND_SERVICE. As a result of this, many containers images that want to use low ports would run as the root user. Additionally the Docker daemon included CAP_NET_BIND_SERVICE as one of the default capabilities provided to running containers.&lt;/p&gt;

&lt;h2 id=&quot;sysctls-to-the-rescue&quot;&gt;sysctls to the rescue!&lt;/h2&gt;

&lt;p&gt;Effectively the reasons that used to apply for having a set of “privileged” ports no longer really apply, so in version 4.11 of the Linux kernel a new option was introduced to allow system administrators to set the &lt;a href=&quot;https://sysctl-explorer.net/net/ipv4/ip_unprivileged_port_start/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip_unprivileged_port_start&lt;/code&gt; sysctl&lt;/a&gt; to a different value. By setting this to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; you allow unprivileged processes to bind any port.&lt;/p&gt;

&lt;h2 id=&quot;state-of-play-in-container-land&quot;&gt;State of play in container land&lt;/h2&gt;

&lt;p&gt;Looking into how this works in container-land, I got a pleasant surprise which is that the latest version already sets this by default (here’s &lt;a href=&quot;https://github.com/moby/moby/pull/41030&quot;&gt;the commit&lt;/a&gt;), along with allowing ping sockets, so that ping works as an unprivileged user too. As this is a namespaced sysctl, it’s only set in the net namespace of the container, and not set at the host level.&lt;/p&gt;

&lt;p&gt;For Podman, the option isn’t enabled by default, but can be set on a per-container basis with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--sysctl net.ipv4.ip_unprivileged_port_start=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For ContainerD there’s an &lt;a href=&quot;https://github.com/containerd/containerd/issues/4936&quot;&gt;open issue&lt;/a&gt; to add the same default, and it’s possible to add the setting using the same switch as for podman.&lt;/p&gt;

&lt;p&gt;In the Kubernetes project there’s also an &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/102612&quot;&gt;open issue&lt;/a&gt; about enabling this by default.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Allowing unprivileged users to bind low ports is likely to be a safer way to provide this functionality than using setUID root or using capabilities, so it’s good to see things moving in that direction. At the moment I could see some confusion occuring due to differing defaults amongst containerization solutions, but hopefully in the longer run, it’ll all get smoothed out :).&lt;/p&gt;
</description>
				<pubDate>Sat, 03 Jul 2021 20:00:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/07/03/containers-and-low-ports/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/07/03/containers-and-low-ports/</guid>
			</item>
		
			<item>
				<title>A Census of Kubernetes Clusters</title>
				<description>&lt;p&gt;I’ve always been a fan of spelunking around in Internet data sets to see what interesting things I can find, so when I saw that &lt;a href=&quot;https://censys.io/&quot;&gt;Censys&lt;/a&gt; had a new version of their search site, and that it had classified data about Kubernetes clusters, I had to have a look around :) Before I talk about the results, I will say I was very impressed by their new offering, the search speed is amazing for the amount of data and there’s some really useful search filters, some of which I’m using here.&lt;/p&gt;

&lt;p&gt;So with access to the data my goal was to see what information I can find out about Internet facing Kubernetes clusters. There are quite a lot of these around mainly because a lot of managed Kubernetes vendors have defaulted to making the API server Internet accessible by default (top security tip is, turn that off if you don’t need it!)&lt;/p&gt;

&lt;h2 id=&quot;finding-kubernetes-servers-on-the-internet&quot;&gt;Finding Kubernetes Servers on the Internet&lt;/h2&gt;

&lt;p&gt;So our first question is, “how do we know we’ve found a Kubernetes server?”. The first option takes advantage of a peculiarity of how Kubernetes does TLS certificates. In a standard cluster, the API server will have a number of Subject Alternative Name fields which are predictable and consistent. For example, if I dump the API server TLS cert from a kind cluster, I get the following in the SAN field&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DNS:kind-control-plane, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:localhost, IP Address:10.96.0.1, IP Address:172.18.0.2, IP Address:127.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Names like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.default.svc.cluster.local&lt;/code&gt; have been present in pretty much every cluster I’ve looked at, so are probably a reasonable place to start. Censys allows you to search for names in a cert, so with a search like &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.tls.certificates.leaf_data.names%3D%22kubernetes.default.svc.cluster.local%22&quot;&gt;this&lt;/a&gt; we can get some results.&lt;/p&gt;

&lt;p&gt;At the time of writing that’s returning 776795 results, a fair few clusters! This leads on to another question though which is, What versions of Kubernetes are running here?&lt;/p&gt;

&lt;h2 id=&quot;using-kubernetes-unauthenticated-version-endpoint&quot;&gt;Using Kubernetes Unauthenticated Version Endpoint&lt;/h2&gt;

&lt;p&gt;An interesting point about the Kubernetes API server is that, by default, many clusters will make the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/version&lt;/code&gt; endpoint available on the API server without authentication. This endpoint returns specific information like the specific version of Kubernetes in use and the version of golang used when compiling it. Another top security tip is, disable this if you don’t need it!&lt;/p&gt;

&lt;p&gt;However fortunately for our census, many Kubernetes distributions don’t disable this option. In the past I’ve considered scanning the Internet for this info., so I was very happy to find out that Censys had done the hard work for me, and it’s available as a query in their new search API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22%2A%22&quot;&gt;This Search&lt;/a&gt; will give us a list of all the servers which return that information. At just over 90,000 results, that’s not a bad place to start.&lt;/p&gt;

&lt;p&gt;We can then use the very handy “report” feature to automatically extract all the versions and a count for each one. The report can be seen &lt;a href=&quot;https://search.censys.io/search/report?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22*%22&amp;amp;field=services.kubernetes.version_info.git_version&amp;amp;num_buckets=1000&quot;&gt;here&lt;/a&gt;. From that we can see a couple of interesting points immediately. The first one is that many of the clusters have customized version strings, due the distribution vendor modifying the API server binary. Fortunately most of the vendors put a noticable pattern (e.g. ‘gke’ for GKE) so we can form some conclusions about which distributions we’re seeing.&lt;/p&gt;

&lt;h2 id=&quot;splitting-down-the-distributions&quot;&gt;Splitting down the Distributions&lt;/h2&gt;

&lt;p&gt;Looking through the identified distributions, the two largest are GKE and EKS, somewhat unsurprisingly. Based on a lack of any AKS distributions, it looks like Microsoft are blocking access to the version endpoint by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/kubernetes-distros-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the big 3 managed distributions, I noticed quite a lot for IKS (IBM’s managed Kubernetes) and OpenShift. Worth noting if you’re looking at the data, OpenShift doesn’t include their name in the version string but have a tell-tale pattern with a hex string at the end (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.9.1+a0ce1bc657&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&quot;what-versions-are-in-use&quot;&gt;What Versions are In Use?&lt;/h2&gt;

&lt;p&gt;The next interesting question is, what Kubernetes versions are in use? A bit of data manipulation is needed to get the major version from each running cluster, but at the end of it we end up with a chart like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/Kubernetes_versions-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First up, there’s &lt;em&gt;a lot&lt;/em&gt; of unsupported Kubernetes out there. Looking at the major distributions out there, most have dropped support for anything older than 1.17. Based on this, there’s at least 26% of clusters running unsupported versions.&lt;/p&gt;

&lt;p&gt;In particularly notable results, there’s two clusters running Kubernetes 1.2! Both of them appear to be OpenShift clusters.&lt;/p&gt;

&lt;h2 id=&quot;what-else-is-there-to-find&quot;&gt;What else is there to find?&lt;/h2&gt;

&lt;p&gt;I’m just getting started on the search for interesting things, but one thing I noticed by looking through the clusters, you can also find other interesting things. One point I noted was that there are currently over 600 systems running the famous Weave &lt;a href=&quot;https://microservices-demo.github.io/&quot;&gt;Sock Shop&lt;/a&gt; demonstration App. (Censys Search &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=%22WeaveSocks+Demo+App%22&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Amusing results aside, there’s a couple of important points which come out of this data. The first one is that it’s quite easy to fingerprint Kubernetes clusters on the Internet, either via distinctive TLS certificates, or exposed API endpoints.&lt;/p&gt;

&lt;p&gt;The second point is the number of companies running unsupported Kubernetes versions exposed to the Internet. These clusters are unlikely to receive security patches, so they could be a single CVE away from compromise.&lt;/p&gt;

&lt;p&gt;In general, from a security standpoint, I’d very much recommend not exposing your API server directly to the Internet unless you really need to. And if you do, make sure you keep it running a supported version of the software!&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Jun 2021 15:00:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</guid>
			</item>
		
			<item>
				<title>Trying out Cosign</title>
				<description>&lt;p&gt;Container image signing has been a bit of a gap in the security landscape, so I’m always interested in seeing new projects starting up which address it. Docker Content Trust/Notary never really gained traction in v1, and whilst v2 looks very interesting, it’s still in the design phase (AFAIK).&lt;/p&gt;

&lt;p&gt;So seeing the &lt;a href=&quot;https://github.com/sigstore/cosign&quot;&gt;Cosign project&lt;/a&gt; come along as part of the &lt;a href=&quot;https://sigstore.dev/&quot;&gt;Sigstore&lt;/a&gt; initiative, I was interested to take a look at it and see how it works. Sigstore has some really interesting ideas about software transparency logs, but for this blog, I’ll just be looking at the raw image signing process.&lt;/p&gt;

&lt;p&gt;The use case I wanted to look at was the idea of getting a container image that’s built as part of a CI pipeline and making a signature available so that people downloading the image from Docker hub could validate that the image they’re downloading was built by me (well more precisely that it was built by someone who had access to the private key which was used to sign it).&lt;/p&gt;

&lt;h2 id=&quot;installing-cosign&quot;&gt;Installing cosign&lt;/h2&gt;

&lt;p&gt;It’s a golang project, so it’s fairly easy to get started, there’s a single binary available from their &lt;a href=&quot;https://github.com/sigstore/cosign/releases/tag/v0.1.0&quot;&gt;release page&lt;/a&gt; and it has been signed by them.&lt;/p&gt;

&lt;p&gt;Once you’ve got it you can generate a keypair &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign generate-key-pair&lt;/code&gt;. A very important point here, is to set a good long passphrase to protect your private key! This will provide you with a public and private key.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-github-actions-to-build-and-sign-your-image&quot;&gt;Setting up Github Actions to build and sign your image.&lt;/h2&gt;

&lt;p&gt;With cosign installed and working, we need get our CI setup to sign the image as it’s built. Cosign have done this with their setup but I wanted to do things a little differently. They put the private key in the repository and I’d prefer to try and keep it a bit more restricted. I’m sure that they’ve set a good passphrase on the key but making it available publicly does open you up to brute force attacks on the passphrase used, so I’d say ideally you’d want to avoid that.&lt;/p&gt;

&lt;p&gt;The test repo I made for this process is &lt;a href=&quot;https://github.com/raesene/cosign_test&quot;&gt;here&lt;/a&gt;. The image itself is just a super simple Dockerfile based on ubuntu 18.04 which adds the cosign binary to it, the interesting part is the GH actions file &lt;a href=&quot;https://github.com/raesene/cosign_test/blob/main/.github/workflows/ci-build-docker-image.yml&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let’s break down what we’re doing in the action. I’m by no means an expert on these, but this seems to work ok :)&lt;/p&gt;

&lt;p&gt;First step is setting up some output with today’s date in this (&lt;a href=&quot;https://github.community/t/how-can-i-set-an-expression-as-an-environment-variable-at-workflow-level/16516/6&quot;&gt;source&lt;/a&gt;). I’m using that to tag the images.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Get current Date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo &quot;::set-output name=date::$(date +'%Y-%m-%d')&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we’ll log into my account on Docker hub. For this you’ll need to set a secret in the Github repository with a docker hub access token in it.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Docker login&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo ${{secrets.DOCKER_PASSWORD}} | docker login -u raesene --password-stdin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we’ll build the Docker image and push it to Docker Hub.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;build Docker Image&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker build -t raesene/cosign_test:${{steps.date.outputs.date}} .&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push to Docker hub&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker push raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With our new image on Docker Hub, we need to sign it. One thing I thought about this flow is that it doesn’t really protect against an active malicious Registry as they could theoretically modify my image as soon as it’s uploaded then the sign commands hit afterwards. Pretty niche attack in most cases but could be worth considering.&lt;/p&gt;

&lt;p&gt;What I’ve done in advance of this is get the passphrase protected Cosign private key and place it into a Github Secret called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COSIGN_KEY&lt;/code&gt; . In order to have it available for cosign to read, I put it into a file (using a method from &lt;a href=&quot;https://stackoverflow.com/a/59482124/537897&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;place the cosign private key in a file&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$COSIGN_KEY&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/tmp/cosign.key'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bash&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;COSIGN_KEY&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.COSIGN_KEY}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now with the signing key available inside the Action, I can sign the image&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Sign the image pushed&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo -n &quot;${{secrets.COSIGN_KEY_PASSPHRASE}}&quot; | ./cosign sign -key /tmp/cosign.key raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One interesting thing, is how cosign stores signatures. If you look on the Docker Hub page for the image that I’m using in the &lt;a href=&quot;https://hub.docker.com/repository/docker/raesene/cosign_test/tags?page=1&amp;amp;ordering=last_updated&quot;&gt;tags tab&lt;/a&gt; you’ll see that cosign creates tags that it uses inside the repo. I think we’ll be seeing more people using OCI registries for things other than pure container images, but this is the first time I’ve seen a tool take that approach.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-image&quot;&gt;Verifying the image&lt;/h2&gt;

&lt;p&gt;Once you’ve got your image uploaded, anyone can use cosign to verify it. For my test image , the public key is&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;-----BEGIN PUBLIC KEY-----&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoeqsxUUhzWrx70u/dCAf1QgBFMVF&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;eyqWrtbAfwDdjONf9gbhfzURQFyZvcL7ET5PEq36x0OS9enJShKzAJKkEQ==&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;-----END PUBLIC KEY-----&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that saved to a file called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign.pub&lt;/code&gt; you should be able to run&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cosign verify &lt;span class=&quot;nt&quot;&gt;-key&lt;/span&gt; cosign.pub raesene/cosign_test:2021-03-21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get output that looks like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
  - Any certificates were verified against the Fulcio roots.
  - WARNING - THE CERTIFICATE EXPIRY WAS NOT CHECKED. &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COSIGN_EXPERIMENTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 to check!
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Critical&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Identity&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;docker-reference&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Image&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Docker-manifest-digest&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;sha256:9b5a67e1e2e67f60d4e93529ff280f12601586c0c382949f96947001c0c6094f&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;cosign container signature&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Optional&quot;&lt;/span&gt;:null&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you try verifying a tag that doesn’t have a signature like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invalid&lt;/code&gt; tag on that repository using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign verify -key cosign.pub raesene/cosign_test:invalid&lt;/code&gt; you’ll get an error&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: GET https://index.docker.io/v2/raesene/cosign_test/manifests/sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign: MANIFEST_UNKNOWN: manifest unknown&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; map[Tag:sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s early days for cosign (they just hit 0.1 2 days back), but it along with sigstore, look like a really promising area of tech. Hopefully we’ll see more developments in this area and get some great new ideas for image (and general software) signing.&lt;/p&gt;
</description>
				<pubDate>Sun, 21 Mar 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</guid>
			</item>
		
			<item>
				<title>Getting into a bind with Kubernetes</title>
				<description>&lt;p&gt;Following on from &lt;a href=&quot;https://raesene.github.io/blog/2020/12/12/Escalating_Away/&quot;&gt;looking at the escalate verb in Kubernetes RBAC&lt;/a&gt;, I thought it would be worth looking at another one of the unusual verbs you can see in Kubernetes RBAC, bind.&lt;/p&gt;

&lt;p&gt;These two, along with the impersonate verb are operations that are available on some RBAC objects in the Kubernetes API. They’re quite important if you’re looking at designing or auditing Kubernetes rights as they can allow for privilege escalation, so know which principals have access to them is important.&lt;/p&gt;

&lt;p&gt;The bind verb can be applied to roles or clusterroles and allows a principal to bypass a general restriction on (cluster)role binding creation, which stops users who can create role bindings from escalating their privileges by binding to high privilege roles like cluster admin. This restriction is described in the Kubernetes documentation &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/rbac/#restrictions-on-role-binding-creation-or-update&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The way that this works is that, without using bind, a user cannot create a rolebinding or clusterrolebinding to a role or cluster role which has rights that the user themselves does not currently have. So for example if a user with the rights to create rolebindings tries to bind to cluster-admin , this won’t work unless that user already has cluster-admin rights.&lt;/p&gt;

&lt;p&gt;Bind is made available to allow for this restriction to be bypassed.&lt;/p&gt;

&lt;h2 id=&quot;practical-example&quot;&gt;Practical Example&lt;/h2&gt;

&lt;p&gt;Let’s show a practical example of this. First up we’ll create a couple of service accounts to act as our user for this experiment and we’ll call them &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac-binder&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not-rbac-binder&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now we’ll create a couple of cluster roles. Both have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterrolebindings&lt;/code&gt; but one will also have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterroles&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac-binder&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterroles&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bind&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterrolebindings&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;create&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;not-rbac-binder&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterrolebindings&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;create&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we’ll just bind those two clusterroles to their respective service accounts.&lt;/p&gt;

&lt;p&gt;So at this point if we look at our users rights with ` kubectl –as=system:serviceaccount:default:rbac-binder auth can-i –list` we can see that the rbac-binder service account has the following rights&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resources                                       Non-Resource URLs   Resource Names   Verbs
clusterroles.rbac.authorization.k8s.io          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
selfsubjectaccessreviews.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
selfsubjectrulesreviews.authorization.k8s.io    &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
clusterrolebindings.rbac.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api]              &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis]             &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and the not-rbac-binder service account has these rights&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:not-rbac-binder auth can-i &lt;span class=&quot;nt&quot;&gt;--list&lt;/span&gt;
Resources                                       Non-Resource URLs   Resource Names   Verbs
selfsubjectaccessreviews.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
selfsubjectrulesreviews.authorization.k8s.io    &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
clusterrolebindings.rbac.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api]              &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis]             &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now if we try to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not-rbac-binder&lt;/code&gt; to create a clusterrolebinding to cluster-admin, it will fail with the following error message (remember here that we do have create clusterrolebinding rights).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:not-rbac-binder create clusterrolebinding rbac-clusteradmin &lt;span class=&quot;nt&quot;&gt;--clusterrole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&quot;nt&quot;&gt;--serviceaccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;namespace:not-rbac-binder
error: failed to create clusterrolebinding: clusterrolebindings.rbac.authorization.k8s.io &lt;span class=&quot;s2&quot;&gt;&quot;rbac-clusteradmin&quot;&lt;/span&gt; is forbidden: user &lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccount:default:not-rbac-binder&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccounts&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccounts:default&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;system:authenticated&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; is attempting to grant RBAC permissions not currently held:
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;APIGroups:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Resources:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Verbs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;NonResourceURLs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Verbs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then if we try the same operation with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac-binder&lt;/code&gt; it works!&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:rbac-binder create clusterrolebinding rbac-clusteradmin &lt;span class=&quot;nt&quot;&gt;--clusterrole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&quot;nt&quot;&gt;--serviceaccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;namespace:rbac-binder
clusterrolebinding.rbac.authorization.k8s.io/rbac-clusteradmin created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The bind verb on RBAC is a useful piece of Kubernetes RBAC configuration but it’s also a lesser known are of RBAC and one which not all tools might properly understand. As it can allow for privilege escalation, it’s an important thing to check for when creating or auditing roles and clusterroles.&lt;/p&gt;
</description>
				<pubDate>Sat, 16 Jan 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/01/16/Getting-Into-A-Bind-with-Kubernetes/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/01/16/Getting-Into-A-Bind-with-Kubernetes/</guid>
			</item>
		
			<item>
				<title>Kubernetes is a router</title>
				<description>&lt;p&gt;One of the interesting areas of Kubernetes to explore is how it handles networking, and this is a quick post looking at one assumption which can be made about Kubernetes networking and how it doesn’t always hold. Whilst Kubernetes can assign pod IP addresses on the same LAN as the host VM, it’s more normal for the CNI to hand out IP addresses from a separate range, and then implement some kind of overlay networking between the cluster nodes to get traffic from pods on one node, to pods on other nodes. As part of this duty, Kubernetes nodes will often act as routers, so if you can get traffic to the node they’ll happily forward it on.&lt;/p&gt;

&lt;p&gt;This could leave you with the idea that pods aren’t accessible from elsewhere on the LAN that the cluster lives on, which could in turn provide a false sense of security about their accessibility, so it’s important to know that whilst pods aren’t usually accessible, that’s not a security feature.&lt;/p&gt;

&lt;p&gt;To demonstrate this I setup a single node Kubeadm cluster and a client machine on the same LAN. In this setup the cluster node is at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.134&lt;/code&gt; and the client at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.135&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the cluster node if I do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get po -A -o wide&lt;/code&gt; we can see the pod IP addresses for the pods running in the cluster :-&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAMESPACE         NAME                                       READY   STATUS    RESTARTS   AGE   IP                NODE      
calico-system     calico-kube-controllers-546d44f5b7-gchk4   1/1     Running   1          16h   10.8.203.8        kubeadm120
calico-system     calico-node-475ff                          1/1     Running   1          16h   192.168.197.134   kubeadm120
calico-system     calico-typha-54879db669-6m4pr              1/1     Running   1          16h   192.168.197.134   kubeadm120
default           testweb                                    1/1     Running   1          16h   10.8.203.7        kubeadm120
kube-system       coredns-74ff55c5b-pp2kt                    1/1     Running   1          16h   10.8.203.6        kubeadm120
kube-system       coredns-74ff55c5b-x8fzx                    1/1     Running   1          16h   10.8.203.5        kubeadm120
kube-system       etcd-kubeadm120                            1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-apiserver-kubeadm120                  1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-controller-manager-kubeadm120         1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-proxy-kkb2v                           1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-scheduler-kubeadm120                  1/1     Running   1          16h   192.168.197.134   kubeadm120
tigera-operator   tigera-operator-657cc89589-624rj           1/1     Running   2          16h   192.168.197.134   kubeadm120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Whilst some of them (the ones using host networking) are on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.0/24&lt;/code&gt; network, some of the others are on the pod network of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.8.0.0/16&lt;/code&gt; which was configured when I setup the cluster. So, from my client machine, I can’t immediately address services on the pod network. If I try to access the nginx web server on the “testweb” pod, it won’t work, as my client doesn’t know how to route traffic to it.&lt;/p&gt;

&lt;p&gt;However, like the post title says, Kubernetes is a router, so if I can add a route on my client, telling it that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.8.0.0/16&lt;/code&gt; network can be reached via the Kubernetes cluster node, I can get traffic to it!&lt;/p&gt;

&lt;p&gt;This is easily enough done, just add a route like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo route add -net 10.8.0.0 netmask 255.255.0.0 gw 192.168.197.134&lt;/code&gt; and then bingo, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl http://10.8.203.7&lt;/code&gt; will return our nginx container’s home page.&lt;/p&gt;

&lt;h2 id=&quot;why-does-that-work&quot;&gt;Why does that work?&lt;/h2&gt;

&lt;p&gt;So we can then look a bit into why this works. The first part is routing. If we look at the routing table on our cluster node we can see routes for our pods. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;route -n&lt;/code&gt; shows :-&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.197.2   0.0.0.0         UG    100    0        0 ens33
10.8.203.5      0.0.0.0         255.255.255.255 UH    0      0        0 cali8c667e24141
10.8.203.6      0.0.0.0         255.255.255.255 UH    0      0        0 calib967dfbd495
10.8.203.7      0.0.0.0         255.255.255.255 UH    0      0        0 calib9199d171be
10.8.203.8      0.0.0.0         255.255.255.255 UH    0      0        0 calie65c0ecd96a
10.8.203.9      0.0.0.0         255.255.255.255 UH    0      0        0 cali68caf03a5f4
10.8.203.10     0.0.0.0         255.255.255.255 UH    0      0        0 cali78a7a37ae9d
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
192.168.197.0   0.0.0.0         255.255.255.0   U     0      0        0 ens33
192.168.197.2   0.0.0.0         255.255.255.255 UH    100    0        0 ens33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we know the node has a route for the pods which is local as there’s no “G” flag on it. The other part of the equation is packet forwarding. Checking the standard Linux sysctl for this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysctl net.ipv4.ip_forward&lt;/code&gt; we can see that packet fowarding is enabled&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net.ipv4.ip_forward &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So traffic sent to the kubernetes node will be forwarded, based on its routing table, and will get to the pod ok.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a relatively minor point, but one worth remembering, just because you can’t get access to pod IP addresses from outside the cluster by default, it’s not a security barrier you should be relying on. In general services running in pods on the cluster should be secured, just like any other service running in your network as they are likely to be accessible in one way or another. If you do want to restrict access to pods running in a cluster, using &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/network-policies/&quot;&gt;network policies&lt;/a&gt; will be the way to go.&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jan 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/01/03/Kubernetes-is-a-router/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/01/03/Kubernetes-is-a-router/</guid>
			</item>
		
			<item>
				<title>Exploring Rootless Docker</title>
				<description>&lt;p&gt;With the release of Docker 20.10, the rootless containers feature has left experimental status. This is an important step for Docker security as it allows for the entire Docker installation to run with standard user prvivileges, no use of root required. Other container solutions like Podman have had this feature for a while but if your used to Docker’s approach it’s nice to see it being available.&lt;/p&gt;

&lt;p&gt;Docker’s documentation on &lt;a href=&quot;https://docs.docker.com/engine/security/rootless/&quot;&gt;rootless containers&lt;/a&gt; has some information about how this is achieved, but I thought it’d be interesting to have a poke around some of the details of the implementation and what it means for container security, especially as I’ll be adding this to the container security course I do.&lt;/p&gt;

&lt;h2 id=&quot;install-and-use&quot;&gt;Install and Use&lt;/h2&gt;

&lt;p&gt;Setting up rootless containers is pretty straightforward, on Ubuntu at least. You need a couple of packages to be installed (the main one you’ll likely need to add is uidmap) and then you can use Docker’s install script to set it up. Obviously I’d recommend downloading and reading the script rather than following their suggestion to pipe it straight to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sh&lt;/code&gt; but looking through it you’ll see it’s mainly just checking the environment before setting up and then downloading and extracting the necessary binaries to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/bin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once it’s installed and you tell the docker CLI where to find the socket file (in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/run/user/UID/docker.sock&lt;/code&gt; instead of the usual &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/run/docker.sock&lt;/code&gt; ) you can start using Docker. The general use case is pretty much exactly what you’d expect, docker commands work fine, you can pull and run images, execute shells in them, and do most of the other things you’d usually do.&lt;/p&gt;

&lt;p&gt;A couple of limitations are present, specifically no cgroups support, unless you enabled cgroupsv2 at the host level and no use of ping or ports &amp;lt; 1024, but again these can be configured if needed. I’d expect the primary use case for rootless docker to be on shared development boxes and perhaps CI hosts, so these limitations probably are deal breakers and in both cases simple configuration options are available.&lt;/p&gt;

&lt;h2 id=&quot;exploring-under-the-covers&quot;&gt;Exploring under the covers&lt;/h2&gt;

&lt;p&gt;So what’s going on here, and how does it compare to standard Docker.&lt;/p&gt;

&lt;h3 id=&quot;user-namespaces&quot;&gt;User namespaces&lt;/h3&gt;

&lt;p&gt;One of the common security challenges when using containes is that they often run as the root user (uid 0) on the host. Whilst Docker has various layers of security to reduce the risk of this, it’s still a cause of potential security problems.&lt;/p&gt;

&lt;p&gt;So now we’re running Docker without any root acccess, what happens?&lt;/p&gt;

&lt;p&gt;With rootless docker setup, if we do something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name=rootlessweb -d nginx&lt;/code&gt; to start up a container, then run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec rootlessweb whoami&lt;/code&gt; , you’ll get back the answer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;, which shows that the container thinks it’s running as root.&lt;/p&gt;

&lt;p&gt;To see what’s really happening, we can get the PID of the container with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker inspect -f '{{.State.Pid}}' rootlessweb&lt;/code&gt; and then look for that process ID in the output of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef&lt;/code&gt;. What you’ll see is that instead of running as root, it’s running as your user!&lt;/p&gt;

&lt;p&gt;The way this is being done is through the use of &lt;a href=&quot;https://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;user namespaces&lt;/a&gt; which have been available in Docker (but rarely used) for quite some time. Docker is mapping uids inside the container, to different uids outside the container (which is why it needed the uidmap package installed). This allows the contained process to act as though it had root rights, without it actually having root rights to the underlying machine.&lt;/p&gt;

&lt;p&gt;Obviously from a security standpoint this is a big positive as it means that kernel bugs that need real &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uid 0&lt;/code&gt; to work, will be blocked as, from the perspective of the kernel, the process is unprivileged.&lt;/p&gt;

&lt;h2 id=&quot;capabilities&quot;&gt;Capabilities&lt;/h2&gt;

&lt;p&gt;One of the things Docker does as part of its setup is use various layers of isolation on contained processes. One of those layers is capabilities. With this one, you might think it’s not going to apply to rootless containers as capabilities are often described as “piece of root rights” which don’t apply here.&lt;/p&gt;

&lt;p&gt;However, reading the user namespace manpages, we can see that actually capabilities are still used inside user namespaces to restrict access. The important part to remember from a security standpoint is that capabilities in user namespaces can only grant rights to resources governed by that namespace. So having CAP_SYS_ADMIN in a user namespace will get you rights in that namespace, but not rights over the underlying host kernel.&lt;/p&gt;

&lt;p&gt;We can see the capability setup by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pscap&lt;/code&gt; on a host running rootless containers. For example the nginx container from the previous example will look like this&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;8198  8219  rorym       nginx             &lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt;, dac_override, fowner, fsetid, &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt;, setgid, setuid, setpcap, net_bind_service, net_raw, sys_chroot, &lt;span class=&quot;nb&quot;&gt;mknod&lt;/span&gt;, audit_write, setfcap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;apparmor&quot;&gt;AppArmor&lt;/h2&gt;

&lt;p&gt;This one is not supported under rootless containers, so no profiles will be loaded (unlike standard rootful containers).&lt;/p&gt;

&lt;h2 id=&quot;seccomp-filter&quot;&gt;Seccomp filter&lt;/h2&gt;

&lt;p&gt;The standard Docker seccomp filter is enabled when using rootless containers, which you can see by inspecting the proc status for our contained process with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /proc/[PID]/status | grep Seccomp&lt;/code&gt; which should return a value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; showing there’s a seccomp profile applied.&lt;/p&gt;

&lt;h2 id=&quot;container-breakout&quot;&gt;Container breakout&lt;/h2&gt;

&lt;p&gt;So now we’ve looked at the various layers of isolation that are used in docker and how they apply (or don’t) to rootless containers, lets look at some of the practical tools and techniques and what they return when run in a rootless container.&lt;/p&gt;

&lt;h3 id=&quot;the-most-pointless-docker-command-ever&quot;&gt;The most pointless docker command ever&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/&quot;&gt;My favourite docker command&lt;/a&gt; is a good place to start. Running&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--privileged&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--ipc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--volume&lt;/span&gt; /:/host busybox &lt;span class=&quot;nb&quot;&gt;chroot&lt;/span&gt; /host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Generates an error. Both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--pid=host&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--ipc=host&lt;/code&gt; don’t work with rootless containers, after removing those we get dropped to a root shell with access to what &lt;em&gt;looks like&lt;/em&gt; the root filesystem of the underlying host. Trying to modify things, however, shows we’re not in the real root filesystem. We can add files in system directories like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc&lt;/code&gt; , however exiting the container shows that the files haven’t actually been created, so it’s obvious that our volume mount didn’t have the effect it would have had, if we had been running a rootful container.&lt;/p&gt;

&lt;h3 id=&quot;amicontained&quot;&gt;amicontained&lt;/h3&gt;

&lt;p&gt;Running &lt;a href=&quot;https://github.com/genuinetools/amicontained&quot;&gt;amicontained&lt;/a&gt; from inside a rootless container shows that it’s easy to detect that we’re in a user namespace, and indeed information is available about how UIDs are being mapped inside the container&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Container Runtime: docker
Has Namespaces:
        pid: &lt;span class=&quot;nb&quot;&gt;true
        &lt;/span&gt;user: &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;User Namespace Mappings:
        Container -&amp;gt; 0  Host -&amp;gt; 1000    Range -&amp;gt; 1
        Container -&amp;gt; 1  Host -&amp;gt; 100000  Range -&amp;gt; 65536
AppArmor Profile: unconfined
Capabilities:
        BOUNDING -&amp;gt; &lt;span class=&quot;nb&quot;&gt;chown &lt;/span&gt;dac_override fowner fsetid &lt;span class=&quot;nb&quot;&gt;kill &lt;/span&gt;setgid setuid setpcap net_bind_service net_raw sys_chroot &lt;span class=&quot;nb&quot;&gt;mknod &lt;/span&gt;audit_write setfcap
Seccomp: filtering
Blocked Syscalls &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
        MSGRCV SYSLOG SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES FUTIMESAT UNSHARE MOVE_PAGES UTIMENSAT PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PKEY_MPROTECT PKEY_ALLOC PKEY_FREE IO_PGETEVENTS RSEQ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;botb&quot;&gt;botb&lt;/h3&gt;

&lt;p&gt;Using &lt;a href=&quot;https://github.com/brompwnie/botb&quot;&gt;botb&lt;/a&gt; to try and autopwn out of a container that has the docker socket mounted runs us into a problem, which is that it tries to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--pid=host&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--ipc=host&lt;/code&gt; as part of the breakout.&lt;/p&gt;

&lt;p&gt;This is, in general, a possibly interesting point about container breakout tools, as they’re unlikely to take account of rootless containers.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Rootless containers are a great addition to Docker’s repetoire. In situations where you want to have users run docker commands without giving the root access to the underlying host, this will really help out. The setup and usuability are great, but you need to take account of the fact that certain things just won’t work the same way as functions reserved for the root user on the host machine won’t be usuable.&lt;/p&gt;
</description>
				<pubDate>Sat, 19 Dec 2020 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/12/19/rootless_docker/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/12/19/rootless_docker/</guid>
			</item>
		
			<item>
				<title>Escalating Away</title>
				<description>&lt;p&gt;Following a recent run of the container security training course I do, I was poking around a bit with the escalate verb in Kubernetes RBAC and found some interesting points, so thought it’d be worth documenting, as it’s not necessarily the best known part of RBAC.&lt;/p&gt;

&lt;p&gt;The reason we were interested in the escalate verb is to answer the question “If I can get secrets in a standard kubeadm cluster, what are my options for escalating my privileges to cluster-admin?”. This question used to be pretty straightforward as until last year there was a service account in the kube-system namespace which had cluster-admin rights, so you could easily get its secret and be cluster-admin. The service account in question is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterrole-aggregation-controller&lt;/code&gt;. However last year the rights on this service account got changed (at least in part as I pointed it out). From &lt;a href=&quot;https://github.com/kubernetes/kubernetes/commit/8b155e82d876c8130962e61b2235f2bd066abde1&quot;&gt;the commit&lt;/a&gt; you can see that the cluster-admin rights were replaced with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;escalate&lt;/code&gt; rights on cluster roles.&lt;/p&gt;

&lt;p&gt;So that leads to the question, “how can I use this permission?”. Unlike the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;impersonate&lt;/code&gt; verb, there’s no handy kubectl flags to add to instantly escalate your rights. So I was looking for information on the topic (which is pretty sparse) and found this &lt;a href=&quot;https://www.impidio.com/blog/kubernetes-rbac-security-pitfalls&quot;&gt;interesting blog post&lt;/a&gt;, which led to the answer.&lt;/p&gt;

&lt;p&gt;What escalate does is bypass the Kubernetes RBAC check which prevents users who are able to create roles or cluster roles from creating (or editing) these objects to have more rights than they do. So what we can do, once we have the service account token for the clusterrole-aggregation-controller is to edit our own cluster role to increase our permissions?&lt;/p&gt;

&lt;p&gt;We can run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl edit clusterrole system:controller:clusterrole-aggregation-controller&lt;/code&gt; and then edit it to add this to the rules section&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and away you go!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;escalate&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;impersonate&lt;/code&gt; are lesser known features of RBAC but one that you should be aware of if you’re a systems administrator or if you’re looking at security tooling around Kubernetes.&lt;/p&gt;
</description>
				<pubDate>Sat, 12 Dec 2020 13:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/12/12/Escalating_Away/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/12/12/Escalating_Away/</guid>
			</item>
		
	</channel>
</rss>
