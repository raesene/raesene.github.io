<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Raesene's Ramblings</title>
		<description>Things that occur to me</description>
		<link>https://raesene.github.io/</link>
		<atom:link href="https://raesene.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Fun with Capabilities</title>
				<description>&lt;p&gt;Capabilities are an interesting area of Linux security and one which has some application to containers. Whilst the details of how they work have been well documented (I’d recommend reading Adrian Mouat’s two part series &lt;a href=&quot;https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://blog.container-solutions.com/linux-capabilities-in-practice&quot;&gt;here&lt;/a&gt;) I thought it was worth looking at a couple of neat tricks we can use do with file capabilities when using containers.&lt;/p&gt;

&lt;h2 id=&quot;using-file-capabilities-when-youre-not-root&quot;&gt;Using File Capabilities when you’re not root&lt;/h2&gt;

&lt;p&gt;Sometimes, in containerized environments, we are restricted from running as the root user, a notable example being OpenShift, which restricts that by default. However generally in those cases we’ll still get the default set of capabilities that most Linux container runtimes provide. This gives us what are called “bounding” capabilities, but the tricky part is, how do we use those when we’re not running as root?&lt;/p&gt;

&lt;p&gt;Well if you can specify a container image that you control, the answer is to set capabilities on programs inside the image, that way when you use those programs you’ll be able to use the capabilities granted.&lt;/p&gt;

&lt;p&gt;Let’s look at a practical example. In the Dockerfile for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raesene/alpine-noroot-containertools&lt;/code&gt; I’ve got the line&lt;/p&gt;

&lt;div class=&quot;language-Dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;setcap &lt;span class=&quot;s1&quot;&gt;'cap_net_raw,cap_net_bind_service,cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap=+ep'&lt;/span&gt; /bin/busybox
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This sets all the capabilities from the Default Docker set on the busybox program inside this container, and busybox provides all the utilities like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chown&lt;/code&gt; so I can run those commands with the capabilities I’ve specified. There’s a couple of useful side effects to doing this. The first is I can change the permissions of files in the image that I don’t own&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/capability-change-file-perm-in-image.png&quot; alt=&quot;change file perm inside image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;fun, but not really that useful as you can always just change the permissions inside the image while you’re building it. A slightly more useful use case is that if you’re mounting files inside the container from the underlying host, you don’t have to worry about who owns those files or the permissions on them as you can just change the perms, using your file capabilities.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/capability-change-file-perm-on-mounted-dir.png&quot; alt=&quot;change file perm inside image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is a handy way to get round the problem where you’re running your non-root containers, but don’t want to have to remember to change the permissions on files you mount in from the underlying host.&lt;/p&gt;

&lt;h2 id=&quot;moving-files-with-capabilities&quot;&gt;Moving files with Capabilities&lt;/h2&gt;

&lt;p&gt;One challenge, when working with file capabilities, is that it can be hard to move them around without losing the capabilities. Utilities like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp&lt;/code&gt; will generally strip capabilities when they’re used. So if you have a file with capabilities how do you move it somewhere?&lt;/p&gt;

&lt;p&gt;The answer is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tar&lt;/code&gt; which supports that idea. You can create a tar file using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--xattrs&lt;/code&gt; flag and then when you un-tar use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--xattrs-include='security.*'&lt;/code&gt; flag to ensure they’re retained. A notable restriction is that to un-tar using that flag, you need to be root. Another restriction is that not all implementations of tar support those flags (e.g. some versions of busybox).&lt;/p&gt;

&lt;p&gt;So to demo this we’ll use an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu:22.04&lt;/code&gt; image. Our goal is going to be, starting as an ordinary user on the host with Docker rights, get a copy of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim&lt;/code&gt; that will let us edit files owned by root like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt; (N.B. this isn’t really a security hole as Docker access == root in most cases, but it’s fun :) )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/start-container-with-mapped-dir.png&quot; alt=&quot;change file perm inside image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once we’ve got it running first install &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libcap2-bin&lt;/code&gt; which lets us set file capabilities. With those installed we can run this to set our file capabilities.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setcap &lt;span class=&quot;s1&quot;&gt;'cap_net_raw,cap_net_bind_service,cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap=+ep'&lt;/span&gt; /usr/bin/vim.basic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we can tar our copy of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim.basic&lt;/code&gt; up in our mounted directory, and then untar it in the same place (so that the capabilities are preserved)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/tar-file-capabilities.png&quot; alt=&quot;change file perm inside image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, with our copy of vim that has caps ready, exit the container and try to edit a file that we should not have access to on the host, and it should work just fine, thanks to the capabilities applied (specifically &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAC_OVERRIDE&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;To bring it all together here’s a video showing all the steps&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Ha7PRo1OnCE&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;File capabilities are an interesting area to explore when working with containers (and in Linux in general) whilst the security model has been pretty well thought out, there are cases where you can make use of them to allow things that might otherwise be tricky :)&lt;/p&gt;

</description>
				<pubDate>Sun, 31 Jul 2022 09:10:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2022/07/31/Fun-With-Capabilities/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2022/07/31/Fun-With-Capabilities/</guid>
			</item>
		
			<item>
				<title>Let's talk about Kubernetes on the Internet</title>
				<description>&lt;p&gt;There’s been a couple of studies recently released by security research companies about exposed Kubernetes clusters on the Internet, and whilst it’s nice to see the security industry focusing a bit more on Kubernetes, some of the analysis misses some of the details of why Kubernetes clusters are exposed to the Internet and what some of the results mean, so I thought it would be a good opportunity to &lt;a href=&quot;https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/&quot;&gt;revist&lt;/a&gt; this topic, also as there have been some developments in what information can be found via Internet search engines.&lt;/p&gt;

&lt;h2 id=&quot;background---kubernetes-network-footprint&quot;&gt;Background - Kubernetes Network footprint&lt;/h2&gt;

&lt;p&gt;Kubernetes is made up of a number of REST APIs which are commonly exposed on network ports. We’ve got&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/&quot;&gt;Kubernetes API server&lt;/a&gt;. commonly exposed on 443/TCP, 6443/TCP or 8443/TCP.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/&quot;&gt;Kubelet&lt;/a&gt;. Commonly exposed on 10250/TCP and (in older clusters) 10255/TCP&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://etcd.io/&quot;&gt;Etcd&lt;/a&gt; - Commonly exposed on 2379/TCP and 2380/TCP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s also an additional set of listening ports but in &lt;em&gt;most&lt;/em&gt; clusters these will be bound to localhost, so won’t show up in our Internet scanning&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/&quot;&gt;Kubernetes Controller Manager&lt;/a&gt;. Defaults to 10257/TCP in recent Kubernetes version.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/&quot;&gt;Kubernetes Scheduler&lt;/a&gt;. Defaults to 10259/TCP in recent Kubernetes versions.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/&quot;&gt;Kube-Proxy&lt;/a&gt;. Defaults to 10256/TCP.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So from an Internet scanning perspective we’ve got a range of ports to look for. The API Server, Kubelet and etcd are also likely to be the most significant from a security standpoint, if they’re mis-configured, so it makes sense to focus there.&lt;/p&gt;

&lt;h2 id=&quot;finding-kubernetes-clusters&quot;&gt;Finding Kubernetes Clusters&lt;/h2&gt;

&lt;p&gt;So now we know the network ports and services we’re looking for, how can we reliably identify that what we’re talking to is a Kubernetes service?&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-api-server&quot;&gt;Kubernetes API Server&lt;/h3&gt;

&lt;h4 id=&quot;tls-certificate-information&quot;&gt;TLS Certificate Information&lt;/h4&gt;

&lt;p&gt;Kubernetes API servers are secured by TLS and as they are contacted by clients both inside and outside the cluster, they need to make sure they have name fields which match the various ways they can be contacted. This is handled by putting information into the Subject Alternative Name field in their certificates.&lt;/p&gt;

&lt;p&gt;If we look at a standard &lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/&quot;&gt;Kubeadm&lt;/a&gt; cluster we can see some of that information.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ssl-cert: Subject: commonName=kube-apiserver
| Subject Alternative Name: DNS:kubeadm2nodemaster, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:10.96.0.1, IP Address:192.168.41.77
| Issuer: commonName=kubernetes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From this there’s a couple of points that are worth noting. Firstly internal cluster IP addresses are leaked (useful for Internet based attackers doing reconnaissance), secondly there are names that will typically appear on &lt;em&gt;every&lt;/em&gt; Kubernetes cluster, making identification easy. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.default.svc.cluster.local&lt;/code&gt; is the DNS name used for clients inside the cluster network to connect to the API server so will be present in pretty much every cluster.&lt;/p&gt;

&lt;h4 id=&quot;response-codes&quot;&gt;Response codes&lt;/h4&gt;

&lt;p&gt;In addition to the TLS certificate information we can also tell some things about an API server based on the response codes we get. For most clusters, if you try to curl the root path of the API server you’ll get a response something like this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k https://192.168.41.77:6443
{
  &quot;kind&quot;: &quot;Status&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {

  },
  &quot;status&quot;: &quot;Failure&quot;,
  &quot;message&quot;: &quot;forbidden: User \&quot;system:anonymous\&quot; cannot get path \&quot;/\&quot;&quot;,
  &quot;reason&quot;: &quot;Forbidden&quot;,
  &quot;details&quot;: {

  },
  &quot;code&quot;: 403
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What this indicates is that we are being authenticated to the API server (so anonymous authentication is enabled, which is the default) but that we’re not authorized to get that URL. You can see from the response that we’ve been assigned the username &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:anonymous&lt;/code&gt; which is given to any requests made without other credentials.&lt;/p&gt;

&lt;p&gt;Whilst 403 responses are the most common from the API server, a Kubernetes API server will respond with a 401 (unauthorized) instead. The most obvious one would be if anonymous authentication is disabled on the API server. Also if HTTP basic authentication (only available till 1.19) or token authentication are enabled and an incorrect set of credentials provided a 401 will also be returned.&lt;/p&gt;

&lt;p&gt;Obviously there’s another option for response codes which is 200. This would occur for a path which is permitted for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:anonymous&lt;/code&gt; user or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:unauthenticated&lt;/code&gt; group. In default Kubernetes there are still a couple of paths that this’ll work for. Most notably for the purposes of fingerprinting Kubernetes clusters &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/version&lt;/code&gt; will generally be visible. Requests to that path will return something like this, which provides quite a bit of information about the running software.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;major&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;minor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;21&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;gitVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;v1.21.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;gitCommit&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;092fbfbf53427de67cac1e9fa54aaa09a28371d7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;gitTreeState&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clean&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;buildDate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2021-06-16T12:53:14Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;goVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;go1.16.5&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;compiler&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;platform&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;linux/amd64&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;kubelet&quot;&gt;Kubelet&lt;/h3&gt;

&lt;p&gt;Typically identifying the Kubelet is relatively straightforward as there aren’t a large number of common services which use 10250/TCP and/or 10255/TCP.&lt;/p&gt;

&lt;h4 id=&quot;kubelet-response-codes&quot;&gt;Kubelet Response Codes&lt;/h4&gt;

&lt;p&gt;Usually the Kubelet will return a 404 response when the root path it queried. This indicates that anonymous authentication is enabled (which is the default) but that it doesn’t have anything present at that URL. Querying a valid path for the API (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/pods&lt;/code&gt;) will return a 401 unauthorized message, unless the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alwaysAllow&lt;/code&gt; authorization mechanism is set-up, when that path would return a list of the pods on the node.&lt;/p&gt;

&lt;p&gt;In the event that 10255/TCP is visible on a cluster (only older versions) this is the unauthenticated Kubelet “read-only” port which will return a detailed list of pods running on the node.&lt;/p&gt;

&lt;h3 id=&quot;etcd&quot;&gt;etcd&lt;/h3&gt;

&lt;p&gt;Like the Kubelet etcd runs on a reasonably unusual set of ports (2379/TCP and 2380/TCP). A running etcd instance may not be related to a Kubernetes cluster as it can be used independently, but when seen along-side ports like 10250/TCP it’s a fair bet it’s support a Kubernetes installation.&lt;/p&gt;

&lt;p&gt;When supporting Kubernetes, etcd will almost always be set-up with client certificate authentication only, so requests will just be rejected with a bad certificate error like this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl: (35) error:14094412:SSL routines:ssl3_read_bytes:sslv3 alert bad certificate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;finding-kubernetes-clusters-on-the-internet&quot;&gt;Finding Kubernetes Clusters on the Internet&lt;/h2&gt;

&lt;p&gt;So now we know what we’re looking for, how do we find it? Luckily, there are multiple Internet search engines which provide filters to make finding Kubernetes ports easy. &lt;a href=&quot;https://shodan.io&quot;&gt;Shodan&lt;/a&gt;, &lt;a href=&quot;https://censys.io/&quot;&gt;Censys&lt;/a&gt; and &lt;a href=&quot;https://www.binaryedge.io/&quot;&gt;Binary Edge&lt;/a&gt; are all options. In addition to pre-packed filters we can also use certain features of how Kubernetes to identify services listening on the Internet (or any other network).&lt;/p&gt;

&lt;p&gt;Of the three Shodan currently finds the most servers, to let’s look at some of the options to find things there. Some of the query results below will require a shodan account to look at so I’ve put screenshots for some of the more interesting information.&lt;/p&gt;

&lt;h3 id=&quot;basic-information-for-exposed-clusters&quot;&gt;Basic Information for exposed clusters&lt;/h3&gt;

&lt;p&gt;The most basic search available is one for &lt;a href=&quot;https://www.shodan.io/search?query=product%3A%22Kubernetes%22&quot;&gt;product:”Kubernetes”&lt;/a&gt;. This currently returns 1.3M results. Of these ~240k are Kubelets, so that leaves us with a bit over a million likely Kubernetes API servers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-product-kubernetes.png&quot; alt=&quot;shodan basic results&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So the first question that likely occurs is “why are there so many Kubernetes services on the Internet?”. Whilst there’s a number of reasons, the major one comes down to the defaults used by the 3 major managed Kubernetes services, EKS, AKS and GKE. All of these services default to putting the API server directly on the Internet, and we can see evidence of this from Shodan’s reporting of the netblock owners for the various exposed services.&lt;/p&gt;

&lt;p&gt;Looking at the &lt;a href=&quot;https://www.shodan.io/search/facet?query=product%3A%22Kubernetes%22&amp;amp;facet=org&quot;&gt;organizations&lt;/a&gt; for this we can see the largest are Google, Amazon and Microsoft respectively and that they account for well over 600k of the exposed services.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-kubernetes-orgs.png&quot; alt=&quot;shodan org results&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next likely interesting point is around the versions of Kubernetes running on the exposed services. Shodan (like the other Internet search engines) pull that information out by querying the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/version&lt;/code&gt; endpoint where it’s exposed.&lt;/p&gt;

&lt;p&gt;Looking at the &lt;a href=&quot;https://www.shodan.io/search/facet?query=product%3A%22Kubernetes%22&amp;amp;facet=version&quot;&gt;version information&lt;/a&gt; we can see a couple of interesting things. Firstly we see EKS and GKE versions there but not AKS. This is because, by default, both Amazon and Google make that endpoint available without authentication and Microsoft does not.&lt;/p&gt;

&lt;p&gt;Looking at the top versions available the other interesting point is that, while most are recent’ish, they’re still falling behind the latest available (1.24) and quite a large number of clusters are running unsupported versions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-exposed-versions.png&quot; alt=&quot;shodan version results&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;response-code-variations&quot;&gt;Response code variations&lt;/h3&gt;

&lt;p&gt;One of the things that was reported on by other research was around the response codes for Kubernetes API servers. Looking at the information on Shodan we can see something quite interesting about the split of responses. The majority of API servers respond with the 403 forbidden code as shown &lt;a href=&quot;https://www.shodan.io/search?query=product%3A%22Kubernetes%22+403&quot;&gt;here&lt;/a&gt; and looking at the responses for 401 unauthorized &lt;a href=&quot;https://www.shodan.io/search?query=product%3A%22Kubernetes%22+401&quot;&gt;here&lt;/a&gt; what we can see is that the vast majority of them are in Microsoft’s netblock space. The likely explanation here is that Microsoft’s AKS product is that they’re disabling anonymous authentication to the API server or they’re using some kind of additional load balancer or proxy in front of the API servers which is returning 401 to requests to the root path.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-kubernetes-401.png&quot; alt=&quot;shodan 401 response code results&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kubelets&quot;&gt;Kubelets&lt;/h3&gt;

&lt;p&gt;Searching for what we know about Kubelets, we can see &lt;a href=&quot;https://www.shodan.io/search?query=product%3A%22Kubernetes%22+http.status%3A%22404%22+port%3A%2210250%22&quot;&gt;results for a response code of 404 on port 10250/TCP&lt;/a&gt;. It’s kind of interesting that there are as many results as this as, while there’s some reasons why you might want the API server directly connected to the Internet, there’s not many reasons to directly expose the Kubelet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-kublets-exposed.png&quot; alt=&quot;shodan kubelet results&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;etcd-1&quot;&gt;Etcd&lt;/h3&gt;

&lt;p&gt;Tracking down etcd hosts is a little more difficult. As, by default, they won’t actually form a connection without a valid client certificate. We can look at Shodan’s data for &lt;a href=&quot;https://www.shodan.io/search?query=port%3A%222379%22&quot;&gt;port 2379&lt;/a&gt;. In there there’s a subset of results for a product of etcd and looking at &lt;a href=&quot;https://www.shodan.io/search?query=port%3A%222379%22+product%3A%22etcd%22&quot;&gt;the results&lt;/a&gt; what’s interesting is that these are essentially unauthenticated etcd services, which may or may not be related to Kubernetes clusters.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/shodan-unauth-etcd.png&quot; alt=&quot;shodan unauth etcd results&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;The goal here was just to record a bit of information about Kubernetes network attack surface, some of the tricks of identifying Kubernetes clusters based on their responses to basic requests and look at what information is visible on the Internet relating to exposed Kubernetes services.&lt;/p&gt;

&lt;p&gt;Possibly the most important point here is that if you’re using one of the major managed Kubernetes distributions, you’re possibly exposing more information than you want to via the exposed API server port, and if you can, it’s a good idea to remove that exposure by restricting access to your cluster.&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jul 2022 09:10:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2022/07/03/lets-talk-about-kubernetes-on-the-internet/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2022/07/03/lets-talk-about-kubernetes-on-the-internet/</guid>
			</item>
		
			<item>
				<title>Escaping the Nested Doll with Tailscale</title>
				<description>&lt;p&gt;There are lots of tools which we can use in the container ecosystem to easily create and test applications, but sometimes the networking they create can get a little complex, making it hard to work with and troubleshoot. I came across a scenario recently (for a workshop in Kubecon) where I needed to access a GUI application deployed in a &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;KinD&lt;/a&gt; cluster running in an EC2 instance on AWS, from my laptop. The solution I came up with was to use &lt;a href=&quot;https://tailscale.com/&quot;&gt;Tailscale&lt;/a&gt; and as it seemed like a nice way to solve the problem, I thought it was worth documenting.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-our-nested-doll&quot;&gt;Setting up our Nested Doll&lt;/h2&gt;

&lt;p&gt;Let’s lay out the different networks we’re working with to show up the problem. My client machine is on a LAN and has an assigned IP address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.41.70&lt;/code&gt; (like most home networks I’m using NAT to access the Internet).&lt;/p&gt;

&lt;p&gt;I create an EC2 instance, which gets assigned an external IP address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;52.56.82.230&lt;/code&gt; which is in one of AWS’ subnets. SSH’ing to that host I get an IP address on my AWS subnet of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.31.3.70&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip addr
ens5: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 9001 qdisc mq state UP group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 06:82:28:cc:5d:6c brd ff:ff:ff:ff:ff:ff
    altname enp0s5
    inet 172.31.3.70/20 brd 172.31.15.255 scope global dynamic ens5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then I install Docker and KinD on the EC2. Creating a KinD cluster sets up a new Docker container which acts as my node. That container has an IP address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.18.0.2&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;kind-control-plane ip addr
eth0@if6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then I create a pod in my KinD cluster with the web application that I want to access, which gets an IP address assigned in the pod network range for the cluster of 10.244.0.5&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get po &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; wide
NAME        READY   STATUS    RESTARTS   AGE   IP           NODE                 NOMINATED NODE   READINESS GATES
webserver   1/1     Running   0          13m   10.244.0.5   kind-control-plane   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When all’s said and done, it ends up looking a bit like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/nested-doll.png&quot; alt=&quot;nested doll&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So how do we get easy access to our website?&lt;/p&gt;

&lt;h2 id=&quot;enter-tailscale&quot;&gt;Enter Tailscale&lt;/h2&gt;

&lt;p&gt;Tailscale is a VPN like product that can be installed on a wide range of devices and essentially creates an overlay network for you that means that devices that you connect can easily access services on any other device in the network. As part of this they have a number of ways of deploying Tailscale to Kubernetes clusters, so you can access your services. In this case probably the easiest to setup is the &lt;a href=&quot;https://tailscale.com/kb/1185/kubernetes/#subnet-router&quot;&gt;subnet router&lt;/a&gt; where we can essentially give access to any workload in the Kubernetes pod network by deploying a Tailscale pod to act as a router.&lt;/p&gt;

&lt;p&gt;Once we follow the Tailscale instructions for creating our Kubernetes Subnet router and &lt;a href=&quot;https://tailscale.com/kb/1019/subnets/#step-3-enable-subnet-routes-from-the-admin-console&quot;&gt;authorize the subnet&lt;/a&gt; in the admin panel, our networking looks a bit like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/nested-doll-with-tailscale.png&quot; alt=&quot;nested doll with tailscale&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and if we browse to the pod IP address of our web server (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.244.0.5&lt;/code&gt;) from our local PC, up pops the deployed application, like magic!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/tailscale-webapp-access.png&quot; alt=&quot;webapp over tailscale&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;addendum---getting-cluster-dns&quot;&gt;Addendum - Getting Cluster DNS&lt;/h2&gt;

&lt;p&gt;So a question on this post from &lt;a href=&quot;https://twitter.com/blair_drummond/status/1535952970352930816?s=20&amp;amp;t=9LG336wUxUe36Qjm4BFGwA&quot;&gt;Blair Drummond&lt;/a&gt; was can you get cluster DNS working for this setup? The answer is yes, although it might be a bit fiddly. Let’s walk through an example. For this example to work it’s important, when following the Tailscale instructions above, that you add a route for the service IP address range in Kubernetes as well as the pod IP address range.&lt;/p&gt;

&lt;p&gt;Next, we need to expose our Pod that we created earlier with a service. Services in Kubernetes get DNS names which can be addressed.&lt;/p&gt;

&lt;p&gt;We can do this with something like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl expose pod webserver &lt;span class=&quot;nt&quot;&gt;--port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;80 &lt;span class=&quot;nt&quot;&gt;--target-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we’ve done that, we nee to tell Tailscale to use the Kubernetes DNS service for our service domain of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default.svc.cluster.local&lt;/code&gt;. We can do that in the Tailscale DNS section of their admin app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/tailscale-cluster-dns.png&quot; alt=&quot;webapp over tailscale&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The nameserver IP address we’re using here is the Kubernetes DNS service&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get svc &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                  AGE
kube-dns   ClusterIP   10.96.0.10   &amp;lt;none&amp;gt;        53/UDP,53/TCP,9153/TCP   13m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we’ve got that setup we can reach our webserver that we deployed with a DNS name of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[SERVICENAME].default.svc.cluster.local&lt;/code&gt; and it should work fine :)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s pretty easy to end up with complex network setups when playing around in container land, especially once you add the complexities of Kubernetes pod network to the mix. Fortunately there are solutions out there that make it easier to work with all of this and let you get access wherever you need it :)&lt;/p&gt;
</description>
				<pubDate>Sat, 11 Jun 2022 09:10:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2022/06/11/escaping-the-nested-doll-with-tailscale/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2022/06/11/escaping-the-nested-doll-with-tailscale/</guid>
			</item>
		
			<item>
				<title>Fun with secrets - Where did they go?</title>
				<description>&lt;p&gt;Before I get into this post a quick note that there is no dramatic payoff here, it’s just playing around with something that surprised me in Kubernetes, to understand a bit about what’s going on.&lt;/p&gt;

&lt;p&gt;Kubernetes clusters make use of secrets for a variety of purposes and (for the time being) one of the main ones is to provide credentials to service accounts, so that the workloads running in a cluster can authenticate to the API server. The reason I say “for the time being” is that this feature is being replaced by &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume&quot;&gt;Bound Service Account Token Volumes&lt;/a&gt;, but that’s a matter for another post.&lt;/p&gt;

&lt;p&gt;The way it usually works is that, when you create a service account, Kubernetes will automatically create a secret to go along with it, and then when you specify that service account is to be used in your workload, Kubernetes will automatically mount the secret into the workload for you.&lt;/p&gt;

&lt;p&gt;Whilst this is usually automatic, when I was chatting to &lt;a href=&quot;https://twitter.com/christophetd&quot;&gt;Christophe&lt;/a&gt; the other day, he mentioned that you can manually create secrets and add an annotation to them specifying a service account name. When you do that, Kubernetes will automatically populate the secret with a service account token for that service account.&lt;/p&gt;

&lt;p&gt;When playing around with this and creating new secrets, I noticed something odd. If you specify a service account name that doesn’t exist in your namespace when creating your secret, while kubectl tells you the creation happens ok, the secret never actually appears!. So as an example, if you get a secret like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Secret&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;build-robot-secret&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kubernetes.io/service-account.name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;build-robot&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kubernetes.io/service-account-token&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;save it in a file called, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-robot-secre.yaml&lt;/code&gt; and do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl create -f build-robot-secret.yaml&lt;/code&gt; you get&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; base-secret.yaml
secret/build-robot-secret created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but then if you do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get secrets&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get secrets
NAME                  TYPE                                  DATA   AGE
default-token-nxrbt   kubernetes.io/service-account-token   3      40m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;it’s nowhere to be seen!&lt;/p&gt;

&lt;h2 id=&quot;working-out-whats-happening&quot;&gt;Working out what’s happening&lt;/h2&gt;

&lt;p&gt;So we have a mystery, what is causing our secret (which is valid kubernetes YAML) to seem to be created but apparently vanish after creation. The first thought I had was, maybe it’s being created but not displayed. So to check that, we can look at the contents of the cluster’s etcd database. It’s the canonical store of information for a cluster, so generally a good place to look.&lt;/p&gt;

&lt;p&gt;To do this, I set-up a cluster with etcd authentication turned off (to make things easier to check), using the etcd-noauth playbook from &lt;a href=&quot;https://github.com/raesene/kube_security_lab/&quot;&gt;kube-security-lab&lt;/a&gt;. with that set-up we can rerun our secret creation loop and see what does or doesn’t show up in etcd, using etcdctl.  The layout of the database is pretty straightforward, so we just ask it to show us the contents of /registry/secrets/default, which is all the secrets in the default namespace.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; etcdctl &lt;span class=&quot;nt&quot;&gt;--insecure-transport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--insecure-skip-tls-verify&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--endpoints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;172.18.0.3:2379 get /registry/secrets/default &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--keys-only&lt;/span&gt;
/registry/secrets/default/default-token-nxrbt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at the output, we can see it’s just our default service account token. So now we know that the secret isn’t persisted. Next question is, what happens if we change an existing secret which points to a valid service account, and make it point to an invalid one.&lt;/p&gt;

&lt;p&gt;We can create a valid one like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Secret&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;extra-default-secret&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kubernetes.io/service-account.name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kubernetes.io/service-account-token&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and if we do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get secrets&lt;/code&gt; once we’ve created it, we can see it’s there&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ kubectl get secrets
NAME                   TYPE                                  DATA   AGE
default-token-nxrbt    kubernetes.io/service-account-token   3      5h20m
extra-default-secret   kubernetes.io/service-account-token   3      4s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ok so now if we do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl edit secret extra-default-secret&lt;/code&gt; and change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service-account.name&lt;/code&gt; field to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; what’ll happen… The answer turns out to be that the edit succeeds and the secret vanishes! Checking etcd as above confirms that our secret has gone from the datastore too.&lt;/p&gt;

&lt;h2 id=&quot;why-does-that-happen&quot;&gt;Why does that happen?&lt;/h2&gt;

&lt;p&gt;Knowing a bit about Kubernetes I’ve got a fair idea of why this happens, I’d expect it to be done by one of the &lt;a href=&quot;https://kubernetes.io/docs/concepts/architecture/controller/&quot;&gt;controllers&lt;/a&gt; that Kubernetes use to manage cluster state. There are a wide range of controllers which run as part of the controller-manager component and what they do (roughly) is run a loop watching the state of a certain class of object looking at the desired state. They then make changes to the configuration of the cluster to ensure it stays in that desired state.&lt;/p&gt;

&lt;p&gt;Looking at the docs for &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#token-controller&quot;&gt;Kubernetes service accounts&lt;/a&gt; we see this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TokenController runs as part of kube-controller-manager. It acts asynchronously. It:

    watches ServiceAccount creation and creates a corresponding ServiceAccount token Secret to allow API access.
    watches ServiceAccount deletion and deletes all corresponding ServiceAccount token Secrets.
    watches ServiceAccount token Secret addition, and ensures the referenced ServiceAccount exists, and adds a token to the Secret if needed.
    watches Secret deletion and removes a reference from the corresponding ServiceAccount if needed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So it seems likely, although the docs don’t mention it deleting secrets that don’t match to an existing service account, that this component will be the one deleting our secrets, but how do we check?&lt;/p&gt;

&lt;p&gt;Well Kubernetes auditing should be able to help us here, as all the controllers in Kubernetes send their requests via the API server, so we can look at what happens when we try to create our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-robot-secret&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Running the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl create&lt;/code&gt; from earlier on that cluster confirms the hypothesis. There’s three events which happen.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A create event from the kubernetes-admin user (which is the name of the default first user in a kubeadm cluster)&lt;/li&gt;
  &lt;li&gt;A get event from the tokens-controller. Interestingly here the “user” is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:kube-controller-manager&lt;/code&gt; but the user agent indicates that it’s the tokens-controller.&lt;/li&gt;
  &lt;li&gt;A delete event from the tokens-controller that looks like this&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;kind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Event&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;audit.k8s.io/v1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;level&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;RequestResponse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;auditID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ef0f48eb-a606-4f50-afcd-517268a5cd2e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;stage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ResponseComplete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;requestURI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/api/v1/namespaces/default/secrets/build-robot-secret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;verb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;delete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;system:kube-controller-manager&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;groups&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;system:authenticated&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sourceIPs&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;172.18.0.3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;userAgent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kube-controller-manager/v1.21.1 (linux/amd64) kubernetes/5e58841/tokens-controller&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;objectRef&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;resource&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;secrets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;build-robot-secret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;v1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;responseStatus&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;metadata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;requestObject&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;kind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;DeleteOptions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;v1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;preconditions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;uid&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;16c9f476-34fe-48a0-b623-100f7de93d0f&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Like I mentioned at the top of this post, nothing earthshaking here, but it’s kind of interesting to dig into how Kubernetes controllers which keep the cluster in a desired state are constantly watching and changing resources.&lt;/p&gt;

&lt;p&gt;In terms of impact, outside of a niche scenario where someone was allowed to edit secrets but not delete them, there’s probably no major impact here, but it might help someone understand why a secret that looked like it got created ok, was no longer present in their cluster!&lt;/p&gt;
</description>
				<pubDate>Sat, 12 Feb 2022 14:50:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2022/02/12/fun-with-secrets-copy/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2022/02/12/fun-with-secrets-copy/</guid>
			</item>
		
			<item>
				<title>Fun with unicode - messing with output</title>
				<description>&lt;p&gt;This week there was some research published from Cambridge university called “&lt;a href=&quot;https://www.trojansource.codes/&quot;&gt;Trojan Codes&lt;/a&gt;”, around the potential risks of RTL unicode characters in source code. Whilst this is very much not a new problem, there have been various pieces of research over the years about the difficulties of handling unicode characters, it seemed like a good cue to look at this kind of issue in the context of Kubernetes. So far I’ve not found any security issues caused by this, but I found a couple of things which could be of interest, so thought I’d write it down, in case it’s useful to anyone.&lt;/p&gt;

&lt;h2 id=&quot;putting-unicode-into-kubernetes-manifests&quot;&gt;Putting unicode into Kubernetes manifests&lt;/h2&gt;

&lt;p&gt;So, how do you actually put RTL style codes into Kubernetes manifests? Essentially the format is something like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;\U0000202E&quot;&lt;/code&gt; and putting these codes in a manifest can will change how the information is stored and displayed by Kubernetes. So a concrete example would look like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRoleBinding&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;roleRef&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;User&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U0000202E&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nimda-retsulc&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U0000202C&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you create that manifest and then retrieve it, you can see that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; in the output shows as cluster-admin with a couple of white spaces in front of it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/rtl-unicode.png&quot; alt=&quot;rtl in manifest&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;other-possible-unicode--output-corruption-fun&quot;&gt;Other possible unicode &amp;amp; output corruption fun&lt;/h2&gt;

&lt;p&gt;Another area where this kind of thing can cause problems for visual inspection of output is the use of “homoglyph” attacks. It’s possible to insert characters which look like an ASCII one but which are not (for example this may look like аdmin but actually the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; character is a Cryllic character)&lt;/p&gt;

&lt;p&gt;Another way I noticed that you can possibly corrupt output is by changing the content of an X.509 certificate, there’s more details on that &lt;a href=&quot;https://github.com/kubernetes/kubectl/issues/888&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;where-might-this-cause-a-problem&quot;&gt;Where might this cause a problem?&lt;/h2&gt;

&lt;p&gt;So now we’ve looked at this, the question is, where could this cause problems? The obvious answer here is that, if a cluster administrator is relying on the output of kubectl commands to make security decisions, ways of modifying the output could cause security issues. This is similar to &lt;a href=&quot;https://github.com/kubernetes/kubectl/issues/888&quot;&gt;this issue&lt;/a&gt; in how CSR information can be represented.&lt;/p&gt;

&lt;p&gt;Another idea might be whether this could be used to bypass external admission controllers. If the admission controller and Kubernetes parse the information in different ways, that might be a possibility.&lt;/p&gt;

&lt;p&gt;It’s not a problem for the project specifically, but it is something that cluster operators should be aware of.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The complexities which go with unicode characters are definitely one to be aware of with regards to their possible security impact. There have been multiple cases in the past where security vulnerabilities have occurred due to misinterpretation of UTF-8 input, and I’m sure there will be more in the future :)&lt;/p&gt;
</description>
				<pubDate>Sat, 06 Nov 2021 08:50:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/11/06/fun-with-unicode/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/11/06/fun-with-unicode/</guid>
			</item>
		
			<item>
				<title>Fun with CRDs - Overwriting core types</title>
				<description>&lt;p&gt;I was playing around with CRDs today when I wondered “what would happen if I tried to overwrite one of Kubernetes’ core object types? The results weren’t what I expected, so thought it was worth writing it down, in case it comes as a surprise to others :) &lt;strong&gt;N.B. There’s an update at the bottom which sheds more light on what happens when you do this&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;whats-a-crd&quot;&gt;What’s a CRD?&lt;/h2&gt;

&lt;p&gt;Kubernetes Custom Resources are a way to extend the core Kubernetes API with custom types. They’re heavily used by various programs which extend Kubernetes functionality, and a common feature of most clusters.  In general, Custom Resources have their own group so, for example if you use Cilium for your kubernetes networking, you’ll have CRDs like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ciliumendpoints.cilium.io&lt;/code&gt; which is the ciliumendpoint object in the cilium.io group.&lt;/p&gt;

&lt;h2 id=&quot;overwriting-core-kubernetes-crds&quot;&gt;Overwriting core Kubernetes CRDs&lt;/h2&gt;

&lt;p&gt;So an obvious question for a curious goose is, what happens if I try to create a CRD with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io&lt;/code&gt; group, which is used by a lot of core Kubernetes objects. Well, let’s find out !&lt;/p&gt;

&lt;p&gt;If we write a basic CRD which starts like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apiextensions.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;CustomResourceDefinition&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;networkpolicies.networking.k8s.io&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;we get an error when we create it. The error handily tells us that we need an annotation added to create a CRD in this group&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The CustomResourceDefinition &quot;networkpolicies.networking.k8s.io&quot; is invalid: metadata.annotations[api-approved.kubernetes.io]: Required value: protected groups must have approval annotation &quot;api-approved.kubernetes.io&quot;, see https://github.com/kubernetes/enhancements/pull/1111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There’s no validation on the contents of this annotation, so I just took the sample one from the GH issue. After I did that, it works! The first time I created a CRD overwriting the Network Policy object, I had it as a namespace scoped object and the results were unexpected.&lt;/p&gt;

&lt;p&gt;Checking &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get crds&lt;/code&gt; shows that it created ok (The one I created didn’t have an egress field)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get crds
NAME                                CREATED AT
networkpolicies.networking.k8s.io   2021-11-01T19:28:04Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but if I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt; on the object, the definition I get back is the original core object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl explain networkpolicies.networking.k8s.io.spec
KIND:     NetworkPolicy
VERSION:  networking.k8s.io/v1

RESOURCE: spec &amp;lt;Object&amp;gt;

DESCRIPTION:
     Specification of the desired behavior for this NetworkPolicy.

     NetworkPolicySpec provides the specification of a NetworkPolicy

FIELDS:
   egress       &amp;lt;[]Object&amp;gt;
     List of egress rules to be applied to the selected pods. Outgoing traffic
     is allowed if there are no NetworkPolicies selecting the pod (and cluster
     policy otherwise allows the traffic), OR if the traffic matches at least
     one egress rule across all of the NetworkPolicy objects whose podSelector
     matches the pod. If this field is empty then this NetworkPolicy limits all
     outgoing traffic (and serves solely to ensure that the pods it selects are
     isolated by default). This field is beta-level in 1.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also if I try to create a sample network policy which uses the original object type, it works ok. So the CRD is there, but it’s not working.&lt;/p&gt;

&lt;p&gt;What happens if you change the scope in the CRD from namespaced to cluster? Well now, it shows in the CRD list &lt;em&gt;and&lt;/em&gt; it’s overwritten the object definition retrieved by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl explain networkpolicies.networking.k8s.io.spec
KIND:     NetworkPolicy
VERSION:  networking.k8s.io/v1

RESOURCE: spec &amp;lt;Object&amp;gt;

DESCRIPTION:
     &amp;lt;empty&amp;gt;

FIELDS:
   name &amp;lt;string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and if I try to create a Network Policy, I get an error showing that it doesn’t understand those field, so this has overwritten the core object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: error validating &quot;sample-netpol.yaml&quot;: error validating data: [ValidationError(NetworkPolicy.spec): unknown field &quot;egress&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;ingress&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;podSelector&quot; in io.k8s.networking.v1.NetworkPolicy.spec, ValidationError(NetworkPolicy.spec): unknown field &quot;policyTypes&quot; in io.k8s.networking.v1.NetworkPolicy.spec]; if you choose to ignore these errors, turn validation off with --validate=false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;other-examples&quot;&gt;Other examples&lt;/h2&gt;

&lt;p&gt;There’s more prodding at this to be done, but a fun additional one I noticed is that if you try to create a CRD with a name of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users.authentication.k8s.io&lt;/code&gt; it creates, but the result isn’t visible in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl api-resources&lt;/code&gt; and you can’t use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl explain&lt;/code&gt; on it, even though it’s not overwriting a visible Object type.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;From a security standpoint, the takeaway here is, don’t let anyone create CRDs in your cluster unless you really really trust them, &lt;del&gt;as they can modify Kubernetes core behaviour&lt;/del&gt;. Also if you’re planning to appear on Rawkode’s klustered show, you could try this and hope the cluster fixers don’t read my blog :)&lt;/p&gt;

&lt;h2 id=&quot;update-03112021&quot;&gt;Update 03/11/2021&lt;/h2&gt;

&lt;p&gt;Curious to get some details on was going on behind the scenes and possible security implications, I asked on k8s slack (a great source of information), and the inimitable &lt;a href=&quot;https://twitter.com/liggitt&quot;&gt;Jordan Liggitt&lt;/a&gt; was able to explain it. It seems like this doesn’t actually overwrite the core Kubernetes types, but what it does do is modify OpenAPI schemes used by clients like Kubectl to validate data being passed to the API server. So, in effect this could break tooling or produce odd behaviour but isn’t modifying the core Kubernetes API. There’s an issue in the &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/106056&quot;&gt;Kubernetes Github repo&lt;/a&gt; with more info.&lt;/p&gt;

&lt;p&gt;To me, it’s still interesting, but in a slightly different way as it illuminates how some of the different components in Kubernetes work together and some of the possible complexity when unusual or unexpected changes are made.&lt;/p&gt;
</description>
				<pubDate>Mon, 01 Nov 2021 08:50:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/11/01/fun-with-CRDs/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/11/01/fun-with-CRDs/</guid>
			</item>
		
			<item>
				<title>Restricting Docker Access With a Reverse Proxy</title>
				<description>&lt;p&gt;One of the things that comes up a lot with Docker security is that, by default, the authorization model is all or nothing. Essentially any user or process that has access to the Docker socket (or Docker TCP port if it’s configured to listen on a network) can use any of its functions. This means that from a security standpoint essentially any user with Docker access can get root on the host &lt;a href=&quot;https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/&quot;&gt;easily&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is a bit of a problem if you have something like monitoring software, which you want to be able to get stats on running containers, but you don’t really want it to have access to all of Docker’s functionality. So I was wondering, what would be a good way to restrict it, so you can let the monitoring software see the information it needs, without giving it root rights to the host.&lt;/p&gt;

&lt;h2 id=&quot;http-apis-and-reverse-proxies&quot;&gt;HTTP APIs and Reverse Proxies&lt;/h2&gt;

&lt;p&gt;As Docker is essentially an HTTP API, one idea would be to use a reverse proxy to sit in front of it and filter what paths are available. Ideally it would be good to have a proxy that understands unix socket files, so we don’t need to expose Docker on the network to make it work. Luckily a brief bit of searching showed me there were some good options and in particular &lt;a href=&quot;https://caddyserver.com/&quot;&gt;Caddy&lt;/a&gt; looked like it would fit the bill. As an aside the initial version of Caddy I tried (v2.4.3) would hang with some Docker responses but the latest version (v2.4.5) should be fine.&lt;/p&gt;

&lt;p&gt;Before I get into the details, I’ll mention this is just a PoC, I wouldn’t rely on it in production without more work and testing, but the basics work fine :)&lt;/p&gt;

&lt;h2 id=&quot;setting-up-a-docker-reverse-proxy-with-caddy&quot;&gt;Setting up a Docker Reverse Proxy with Caddy&lt;/h2&gt;

&lt;p&gt;After installing Caddy the first thing to do was make sure it worked the way I expected. For that a simple Caddyfile like this one does the trick&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  debug
}


http://localhost:2379 {
  reverse_proxy unix///var/run/docker.sock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will expose a network port of 2379/TCP and just send on any requests to the Docker socket. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debug&lt;/code&gt; stanza at the top just gets Caddy to output verbose information which is handy when working out what’s happening.&lt;/p&gt;

&lt;p&gt;With that in place we can just tell Docker to connect to that port and see if it works using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H&lt;/code&gt; switch&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -H tcp://localhost:2379 info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That works just fine and we can see in the Caddy debug log, the requests going through the proxy to Docker&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2021/09/05 08:37:07.052 DEBUG   http.handlers.reverse_proxy     upstream roundtrip      {&quot;upstream&quot;: &quot;unix///var/run/docker.sock&quot;, &quot;request&quot;: {&quot;remote_addr&quot;: &quot;127.0.0.1:55376&quot;, &quot;proto&quot;: &quot;HTTP/1.1&quot;, &quot;method&quot;: &quot;HEAD&quot;, &quot;host&quot;: &quot;localhost:2379&quot;, &quot;uri&quot;: &quot;/_ping&quot;, &quot;headers&quot;: {&quot;User-Agent&quot;: [&quot;Docker-Client/20.10.8 (linux)&quot;], &quot;X-Forwarded-Proto&quot;: [&quot;http&quot;], &quot;X-Forwarded-For&quot;: [&quot;127.0.0.1&quot;]}}, &quot;headers&quot;: {&quot;Pragma&quot;: [&quot;no-cache&quot;], &quot;Server&quot;: [&quot;Docker/20.10.8 (linux)&quot;], &quot;Date&quot;: [&quot;Sun, 05 Sep 2021 08:37:07 GMT&quot;], &quot;Api-Version&quot;: [&quot;1.41&quot;], &quot;Content-Length&quot;: [&quot;0&quot;], &quot;Content-Type&quot;: [&quot;text/plain; charset=utf-8&quot;], &quot;Cache-Control&quot;: [&quot;no-cache, no-store, must-revalidate&quot;], &quot;Docker-Experimental&quot;: [&quot;false&quot;], &quot;Ostype&quot;: [&quot;linux&quot;]}, &quot;status&quot;: 200}
2021/09/05 08:37:07.067 DEBUG   http.handlers.reverse_proxy     upstream roundtrip      {&quot;upstream&quot;: &quot;unix///var/run/docker.sock&quot;, &quot;request&quot;: {&quot;remote_addr&quot;: &quot;127.0.0.1:55376&quot;, &quot;proto&quot;: &quot;HTTP/1.1&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;host&quot;: &quot;localhost:2379&quot;, &quot;uri&quot;: &quot;/v1.41/info&quot;, &quot;headers&quot;: {&quot;X-Forwarded-For&quot;: [&quot;127.0.0.1&quot;], &quot;User-Agent&quot;: [&quot;Docker-Client/20.10.8 (linux)&quot;], &quot;X-Forwarded-Proto&quot;: [&quot;http&quot;]}}, &quot;headers&quot;: {&quot;Api-Version&quot;: [&quot;1.41&quot;], &quot;Content-Type&quot;: [&quot;application/json&quot;], &quot;Docker-Experimental&quot;: [&quot;false&quot;], &quot;Ostype&quot;: [&quot;linux&quot;], &quot;Server&quot;: [&quot;Docker/20.10.8 (linux)&quot;], &quot;Date&quot;: [&quot;Sun, 05 Sep 2021 08:37:07 GMT&quot;]}, &quot;status&quot;: 200}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This information is useful because it lets us know what paths we need to whitelist for our restrictive proxy. It’s important to try and whitelist the paths you definitely need and not try to blacklist the paths you don’t need, otherwise one missing path could ruin your whole day.&lt;/p&gt;

&lt;p&gt;With that setup in place, we can just run all the Docker commands we want our monitoring software to do and build out a set of paths that should be allowed by the proxy. My set ended up like this.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  debug
}

http://localhost:2379 {
  @infourl {
    method GET
    path /v1.41/info
  }

  @pingurl {
    method HEAD
    path /_ping
  }

  @versionurl {
    method GET
    path /v1.41/version
  }

  @eventsurl {
    method GET
    path /v1.41/events
  }

  @statsurl {
    method GET
    path /v1.41/stats
  }

  @containerstatsurl {
    method GET
    path /v1.41/containers/*/stats
  }

  @containersurl {
    method GET
    path /v1.41/containers/json
  }

  reverse_proxy @pingurl unix///var/run/docker.sock
  reverse_proxy @infourl unix///var/run/docker.sock
  reverse_proxy @versionurl unix///var/run/docker.sock
  reverse_proxy @eventsurl unix///var/run/docker.sock
  reverse_proxy @statsurl unix///var/run/docker.sock
  reverse_proxy @containerstatsurl unix///var/run/docker.sock
  reverse_proxy @containersurl unix///var/run/docker.sock
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that set of paths in place, software should be able to gather stats, list Docker engine information and list the running containers.  If the client tries any other operation it just produces an EOF error.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -H tcp://localhost:2379 images
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So this is one option for trying to provide a restricted view of the Docker API for things like monitoring tools. Getting to something production ready would obviously require more work, but the basic concept is interesting.&lt;/p&gt;
</description>
				<pubDate>Sun, 05 Sep 2021 09:50:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/09/05/restricting-docker-access-with-a-proxy/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/09/05/restricting-docker-access-with-a-proxy/</guid>
			</item>
		
			<item>
				<title>Containers and Low Ports</title>
				<description>&lt;p&gt;I had cause to look into unprivileged binding of ports in Docker containers recently, and found a couple of things that were a surprise to me, so taking the time to write them down, in case it’s of use to anyone else.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;Traditionally, on a Linux system, to bind a port lower than 1024 a process either had to be run by the root user, be setUID root or have CAP_NET_BIND_SERVICE. As a result of this, many containers images that want to use low ports would run as the root user. Additionally the Docker daemon included CAP_NET_BIND_SERVICE as one of the default capabilities provided to running containers.&lt;/p&gt;

&lt;h2 id=&quot;sysctls-to-the-rescue&quot;&gt;sysctls to the rescue!&lt;/h2&gt;

&lt;p&gt;Effectively the reasons that used to apply for having a set of “privileged” ports no longer really apply, so in version 4.11 of the Linux kernel a new option was introduced to allow system administrators to set the &lt;a href=&quot;https://sysctl-explorer.net/net/ipv4/ip_unprivileged_port_start/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip_unprivileged_port_start&lt;/code&gt; sysctl&lt;/a&gt; to a different value. By setting this to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; you allow unprivileged processes to bind any port.&lt;/p&gt;

&lt;h2 id=&quot;state-of-play-in-container-land&quot;&gt;State of play in container land&lt;/h2&gt;

&lt;p&gt;Looking into how this works in container-land, I got a pleasant surprise which is that the latest version already sets this by default (here’s &lt;a href=&quot;https://github.com/moby/moby/pull/41030&quot;&gt;the commit&lt;/a&gt;), along with allowing ping sockets, so that ping works as an unprivileged user too. As this is a namespaced sysctl, it’s only set in the net namespace of the container, and not set at the host level.&lt;/p&gt;

&lt;p&gt;For Podman, the option isn’t enabled by default, but can be set on a per-container basis with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--sysctl net.ipv4.ip_unprivileged_port_start=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For ContainerD there’s an &lt;a href=&quot;https://github.com/containerd/containerd/issues/4936&quot;&gt;open issue&lt;/a&gt; to add the same default, and it’s possible to add the setting using the same switch as for podman.&lt;/p&gt;

&lt;p&gt;In the Kubernetes project there’s also an &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/102612&quot;&gt;open issue&lt;/a&gt; about enabling this by default.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Allowing unprivileged users to bind low ports is likely to be a safer way to provide this functionality than using setUID root or using capabilities, so it’s good to see things moving in that direction. At the moment I could see some confusion occuring due to differing defaults amongst containerization solutions, but hopefully in the longer run, it’ll all get smoothed out :).&lt;/p&gt;
</description>
				<pubDate>Sat, 03 Jul 2021 20:00:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/07/03/containers-and-low-ports/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/07/03/containers-and-low-ports/</guid>
			</item>
		
			<item>
				<title>A Census of Kubernetes Clusters</title>
				<description>&lt;p&gt;I’ve always been a fan of spelunking around in Internet data sets to see what interesting things I can find, so when I saw that &lt;a href=&quot;https://censys.io/&quot;&gt;Censys&lt;/a&gt; had a new version of their search site, and that it had classified data about Kubernetes clusters, I had to have a look around :) Before I talk about the results, I will say I was very impressed by their new offering, the search speed is amazing for the amount of data and there’s some really useful search filters, some of which I’m using here.&lt;/p&gt;

&lt;p&gt;So with access to the data my goal was to see what information I can find out about Internet facing Kubernetes clusters. There are quite a lot of these around mainly because a lot of managed Kubernetes vendors have defaulted to making the API server Internet accessible by default (top security tip is, turn that off if you don’t need it!)&lt;/p&gt;

&lt;h2 id=&quot;finding-kubernetes-servers-on-the-internet&quot;&gt;Finding Kubernetes Servers on the Internet&lt;/h2&gt;

&lt;p&gt;So our first question is, “how do we know we’ve found a Kubernetes server?”. The first option takes advantage of a peculiarity of how Kubernetes does TLS certificates. In a standard cluster, the API server will have a number of Subject Alternative Name fields which are predictable and consistent. For example, if I dump the API server TLS cert from a kind cluster, I get the following in the SAN field&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DNS:kind-control-plane, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:localhost, IP Address:10.96.0.1, IP Address:172.18.0.2, IP Address:127.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Names like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.default.svc.cluster.local&lt;/code&gt; have been present in pretty much every cluster I’ve looked at, so are probably a reasonable place to start. Censys allows you to search for names in a cert, so with a search like &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.tls.certificates.leaf_data.names%3D%22kubernetes.default.svc.cluster.local%22&quot;&gt;this&lt;/a&gt; we can get some results.&lt;/p&gt;

&lt;p&gt;At the time of writing that’s returning 776795 results, a fair few clusters! This leads on to another question though which is, What versions of Kubernetes are running here?&lt;/p&gt;

&lt;h2 id=&quot;using-kubernetes-unauthenticated-version-endpoint&quot;&gt;Using Kubernetes Unauthenticated Version Endpoint&lt;/h2&gt;

&lt;p&gt;An interesting point about the Kubernetes API server is that, by default, many clusters will make the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/version&lt;/code&gt; endpoint available on the API server without authentication. This endpoint returns specific information like the specific version of Kubernetes in use and the version of golang used when compiling it. Another top security tip is, disable this if you don’t need it!&lt;/p&gt;

&lt;p&gt;However fortunately for our census, many Kubernetes distributions don’t disable this option. In the past I’ve considered scanning the Internet for this info., so I was very happy to find out that Censys had done the hard work for me, and it’s available as a query in their new search API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22%2A%22&quot;&gt;This Search&lt;/a&gt; will give us a list of all the servers which return that information. At just over 90,000 results, that’s not a bad place to start.&lt;/p&gt;

&lt;p&gt;We can then use the very handy “report” feature to automatically extract all the versions and a count for each one. The report can be seen &lt;a href=&quot;https://search.censys.io/search/report?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22*%22&amp;amp;field=services.kubernetes.version_info.git_version&amp;amp;num_buckets=1000&quot;&gt;here&lt;/a&gt;. From that we can see a couple of interesting points immediately. The first one is that many of the clusters have customized version strings, due the distribution vendor modifying the API server binary. Fortunately most of the vendors put a noticable pattern (e.g. ‘gke’ for GKE) so we can form some conclusions about which distributions we’re seeing.&lt;/p&gt;

&lt;h2 id=&quot;splitting-down-the-distributions&quot;&gt;Splitting down the Distributions&lt;/h2&gt;

&lt;p&gt;Looking through the identified distributions, the two largest are GKE and EKS, somewhat unsurprisingly. Based on a lack of any AKS distributions, it looks like Microsoft are blocking access to the version endpoint by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/kubernetes-distros-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the big 3 managed distributions, I noticed quite a lot for IKS (IBM’s managed Kubernetes) and OpenShift. Worth noting if you’re looking at the data, OpenShift doesn’t include their name in the version string but have a tell-tale pattern with a hex string at the end (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.9.1+a0ce1bc657&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&quot;what-versions-are-in-use&quot;&gt;What Versions are In Use?&lt;/h2&gt;

&lt;p&gt;The next interesting question is, what Kubernetes versions are in use? A bit of data manipulation is needed to get the major version from each running cluster, but at the end of it we end up with a chart like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/Kubernetes_versions-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First up, there’s &lt;em&gt;a lot&lt;/em&gt; of unsupported Kubernetes out there. Looking at the major distributions out there, most have dropped support for anything older than 1.17. Based on this, there’s at least 26% of clusters running unsupported versions.&lt;/p&gt;

&lt;p&gt;In particularly notable results, there’s two clusters running Kubernetes 1.2! Both of them appear to be OpenShift clusters.&lt;/p&gt;

&lt;h2 id=&quot;what-else-is-there-to-find&quot;&gt;What else is there to find?&lt;/h2&gt;

&lt;p&gt;I’m just getting started on the search for interesting things, but one thing I noticed by looking through the clusters, you can also find other interesting things. One point I noted was that there are currently over 600 systems running the famous Weave &lt;a href=&quot;https://microservices-demo.github.io/&quot;&gt;Sock Shop&lt;/a&gt; demonstration App. (Censys Search &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=%22WeaveSocks+Demo+App%22&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Amusing results aside, there’s a couple of important points which come out of this data. The first one is that it’s quite easy to fingerprint Kubernetes clusters on the Internet, either via distinctive TLS certificates, or exposed API endpoints.&lt;/p&gt;

&lt;p&gt;The second point is the number of companies running unsupported Kubernetes versions exposed to the Internet. These clusters are unlikely to receive security patches, so they could be a single CVE away from compromise.&lt;/p&gt;

&lt;p&gt;In general, from a security standpoint, I’d very much recommend not exposing your API server directly to the Internet unless you really need to. And if you do, make sure you keep it running a supported version of the software!&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Jun 2021 15:00:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</guid>
			</item>
		
			<item>
				<title>Trying out Cosign</title>
				<description>&lt;p&gt;Container image signing has been a bit of a gap in the security landscape, so I’m always interested in seeing new projects starting up which address it. Docker Content Trust/Notary never really gained traction in v1, and whilst v2 looks very interesting, it’s still in the design phase (AFAIK).&lt;/p&gt;

&lt;p&gt;So seeing the &lt;a href=&quot;https://github.com/sigstore/cosign&quot;&gt;Cosign project&lt;/a&gt; come along as part of the &lt;a href=&quot;https://sigstore.dev/&quot;&gt;Sigstore&lt;/a&gt; initiative, I was interested to take a look at it and see how it works. Sigstore has some really interesting ideas about software transparency logs, but for this blog, I’ll just be looking at the raw image signing process.&lt;/p&gt;

&lt;p&gt;The use case I wanted to look at was the idea of getting a container image that’s built as part of a CI pipeline and making a signature available so that people downloading the image from Docker hub could validate that the image they’re downloading was built by me (well more precisely that it was built by someone who had access to the private key which was used to sign it).&lt;/p&gt;

&lt;h2 id=&quot;installing-cosign&quot;&gt;Installing cosign&lt;/h2&gt;

&lt;p&gt;It’s a golang project, so it’s fairly easy to get started, there’s a single binary available from their &lt;a href=&quot;https://github.com/sigstore/cosign/releases/tag/v0.1.0&quot;&gt;release page&lt;/a&gt; and it has been signed by them.&lt;/p&gt;

&lt;p&gt;Once you’ve got it you can generate a keypair &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign generate-key-pair&lt;/code&gt;. A very important point here, is to set a good long passphrase to protect your private key! This will provide you with a public and private key.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-github-actions-to-build-and-sign-your-image&quot;&gt;Setting up Github Actions to build and sign your image.&lt;/h2&gt;

&lt;p&gt;With cosign installed and working, we need get our CI setup to sign the image as it’s built. Cosign have done this with their setup but I wanted to do things a little differently. They put the private key in the repository and I’d prefer to try and keep it a bit more restricted. I’m sure that they’ve set a good passphrase on the key but making it available publicly does open you up to brute force attacks on the passphrase used, so I’d say ideally you’d want to avoid that.&lt;/p&gt;

&lt;p&gt;The test repo I made for this process is &lt;a href=&quot;https://github.com/raesene/cosign_test&quot;&gt;here&lt;/a&gt;. The image itself is just a super simple Dockerfile based on ubuntu 18.04 which adds the cosign binary to it, the interesting part is the GH actions file &lt;a href=&quot;https://github.com/raesene/cosign_test/blob/main/.github/workflows/ci-build-docker-image.yml&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let’s break down what we’re doing in the action. I’m by no means an expert on these, but this seems to work ok :)&lt;/p&gt;

&lt;p&gt;First step is setting up some output with today’s date in this (&lt;a href=&quot;https://github.community/t/how-can-i-set-an-expression-as-an-environment-variable-at-workflow-level/16516/6&quot;&gt;source&lt;/a&gt;). I’m using that to tag the images.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Get current Date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo &quot;::set-output name=date::$(date +'%Y-%m-%d')&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we’ll log into my account on Docker hub. For this you’ll need to set a secret in the Github repository with a docker hub access token in it.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Docker login&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo ${{secrets.DOCKER_PASSWORD}} | docker login -u raesene --password-stdin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we’ll build the Docker image and push it to Docker Hub.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;build Docker Image&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker build -t raesene/cosign_test:${{steps.date.outputs.date}} .&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push to Docker hub&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker push raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With our new image on Docker Hub, we need to sign it. One thing I thought about this flow is that it doesn’t really protect against an active malicious Registry as they could theoretically modify my image as soon as it’s uploaded then the sign commands hit afterwards. Pretty niche attack in most cases but could be worth considering.&lt;/p&gt;

&lt;p&gt;What I’ve done in advance of this is get the passphrase protected Cosign private key and place it into a Github Secret called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COSIGN_KEY&lt;/code&gt; . In order to have it available for cosign to read, I put it into a file (using a method from &lt;a href=&quot;https://stackoverflow.com/a/59482124/537897&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;place the cosign private key in a file&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$COSIGN_KEY&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/tmp/cosign.key'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bash&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;COSIGN_KEY&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.COSIGN_KEY}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now with the signing key available inside the Action, I can sign the image&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Sign the image pushed&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo -n &quot;${{secrets.COSIGN_KEY_PASSPHRASE}}&quot; | ./cosign sign -key /tmp/cosign.key raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One interesting thing, is how cosign stores signatures. If you look on the Docker Hub page for the image that I’m using in the &lt;a href=&quot;https://hub.docker.com/repository/docker/raesene/cosign_test/tags?page=1&amp;amp;ordering=last_updated&quot;&gt;tags tab&lt;/a&gt; you’ll see that cosign creates tags that it uses inside the repo. I think we’ll be seeing more people using OCI registries for things other than pure container images, but this is the first time I’ve seen a tool take that approach.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-image&quot;&gt;Verifying the image&lt;/h2&gt;

&lt;p&gt;Once you’ve got your image uploaded, anyone can use cosign to verify it. For my test image , the public key is&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;-----BEGIN PUBLIC KEY-----&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoeqsxUUhzWrx70u/dCAf1QgBFMVF&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;eyqWrtbAfwDdjONf9gbhfzURQFyZvcL7ET5PEq36x0OS9enJShKzAJKkEQ==&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;-----END PUBLIC KEY-----&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that saved to a file called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign.pub&lt;/code&gt; you should be able to run&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cosign verify &lt;span class=&quot;nt&quot;&gt;-key&lt;/span&gt; cosign.pub raesene/cosign_test:2021-03-21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get output that looks like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
  - Any certificates were verified against the Fulcio roots.
  - WARNING - THE CERTIFICATE EXPIRY WAS NOT CHECKED. &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COSIGN_EXPERIMENTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 to check!
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Critical&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Identity&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;docker-reference&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Image&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Docker-manifest-digest&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;sha256:9b5a67e1e2e67f60d4e93529ff280f12601586c0c382949f96947001c0c6094f&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;cosign container signature&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Optional&quot;&lt;/span&gt;:null&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you try verifying a tag that doesn’t have a signature like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invalid&lt;/code&gt; tag on that repository using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign verify -key cosign.pub raesene/cosign_test:invalid&lt;/code&gt; you’ll get an error&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: GET https://index.docker.io/v2/raesene/cosign_test/manifests/sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign: MANIFEST_UNKNOWN: manifest unknown&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; map[Tag:sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s early days for cosign (they just hit 0.1 2 days back), but it along with sigstore, look like a really promising area of tech. Hopefully we’ll see more developments in this area and get some great new ideas for image (and general software) signing.&lt;/p&gt;
</description>
				<pubDate>Sun, 21 Mar 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</guid>
			</item>
		
	</channel>
</rss>
