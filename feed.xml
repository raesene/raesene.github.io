<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Raesene's Ramblings</title>
		<description>Things that occur to me</description>
		<link>https://raesene.github.io/</link>
		<atom:link href="https://raesene.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>A Census of Kubernetes Clusters</title>
				<description>&lt;p&gt;I’ve always been a fan of spelunking around in Internet data sets to see what interesting things I can find, so when I saw that &lt;a href=&quot;https://censys.io/&quot;&gt;Censys&lt;/a&gt; had a new version of their search site, and that it had classified data about Kubernetes clusters, I had to have a look around :) Before I talk about the results, I will say I was very impressed by their new offering, the search speed is amazing for the amount of data and there’s some really useful search filters, some of which I’m using here.&lt;/p&gt;

&lt;p&gt;So with access to the data my goal was to see what information I can find out about Internet facing Kubernetes clusters. There are quite a lot of these around mainly because a lot of managed Kubernetes vendors have defaulted to making the API server Internet accessible by default (top security tip is, turn that off if you don’t need it!)&lt;/p&gt;

&lt;h2 id=&quot;finding-kubernetes-servers-on-the-internet&quot;&gt;Finding Kubernetes Servers on the Internet&lt;/h2&gt;

&lt;p&gt;So our first question is, “how do we know we’ve found a Kubernetes server?”. The first option takes advantage of a peculiarity of how Kubernetes does TLS certificates. In a standard cluster, the API server will have a number of Subject Alternative Name fields which are predictable and consistent. For example, if I dump the API server TLS cert from a kind cluster, I get the following in the SAN field&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DNS:kind-control-plane, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:localhost, IP Address:10.96.0.1, IP Address:172.18.0.2, IP Address:127.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Names like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.default.svc.cluster.local&lt;/code&gt; have been present in pretty much every cluster I’ve looked at, so are probably a reasonable place to start. Censys allows you to search for names in a cert, so with a search like &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.tls.certificates.leaf_data.names%3D%22kubernetes.default.svc.cluster.local%22&quot;&gt;this&lt;/a&gt; we can get some results.&lt;/p&gt;

&lt;p&gt;At the time of writing that’s returning 776795 results, a fair few clusters! This leads on to another question though which is, What versions of Kubernetes are running here?&lt;/p&gt;

&lt;h2 id=&quot;using-kubernetes-unauthenticated-version-endpoint&quot;&gt;Using Kubernetes Unauthenticated Version Endpoint&lt;/h2&gt;

&lt;p&gt;An interesting point about the Kubernetes API server is that, by default, many clusters will make the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/version&lt;/code&gt; endpoint available on the API server without authentication. This endpoint returns specific information like the specific version of Kubernetes in use and the version of golang used when compiling it. Another top security tip is, disable this if you don’t need it!&lt;/p&gt;

&lt;p&gt;However fortunately for our census, many Kubernetes distributions don’t disable this option. In the past I’ve considered scanning the Internet for this info., so I was very happy to find out that Censys had done the hard work for me, and it’s available as a query in their new search API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22%2A%22&quot;&gt;This Search&lt;/a&gt; will give us a list of all the servers which return that information. At just over 90,000 results, that’s not a bad place to start.&lt;/p&gt;

&lt;p&gt;We can then use the very handy “report” feature to automatically extract all the versions and a count for each one. The report can be seen &lt;a href=&quot;https://search.censys.io/search/report?resource=hosts&amp;amp;q=services.kubernetes.version_info.git_version%3D%22*%22&amp;amp;field=services.kubernetes.version_info.git_version&amp;amp;num_buckets=1000&quot;&gt;here&lt;/a&gt;. From that we can see a couple of interesting points immediately. The first one is that many of the clusters have customized version strings, due the distribution vendor modifying the API server binary. Fortunately most of the vendors put a noticable pattern (e.g. ‘gke’ for GKE) so we can form some conclusions about which distributions we’re seeing.&lt;/p&gt;

&lt;h2 id=&quot;splitting-down-the-distributions&quot;&gt;Splitting down the Distributions&lt;/h2&gt;

&lt;p&gt;Looking through the identified distributions, the two largest are GKE and EKS, somewhat unsurprisingly. Based on a lack of any AKS distributions, it looks like Microsoft are blocking access to the version endpoint by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/kubernetes-distros-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the big 3 managed distributions, I noticed quite a lot for IKS (IBM’s managed Kubernetes) and OpenShift. Worth noting if you’re looking at the data, OpenShift doesn’t include their name in the version string but have a tell-tale pattern with a hex string at the end (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.9.1+a0ce1bc657&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&quot;what-versions-are-in-use&quot;&gt;What Versions are In Use?&lt;/h2&gt;

&lt;p&gt;The next interesting question is, what Kubernetes versions are in use? A bit of data manipulation is needed to get the major version from each running cluster, but at the end of it we end up with a chart like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raesene.github.io/assets/media/Kubernetes_versions-censys.png&quot; alt=&quot;Distributions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First up, there’s &lt;em&gt;a lot&lt;/em&gt; of unsupported Kubernetes out there. Looking at the major distributions out there, most have dropped support for anything older than 1.17. Based on this, there’s at least 26% of clusters running unsupported versions.&lt;/p&gt;

&lt;p&gt;In particularly notable results, there’s two clusters running Kubernetes 1.2! Both of them appear to be OpenShift clusters.&lt;/p&gt;

&lt;h2 id=&quot;what-else-is-there-to-find&quot;&gt;What else is there to find?&lt;/h2&gt;

&lt;p&gt;I’m just getting started on the search for interesting things, but one thing I noticed by looking through the clusters, you can also find other interesting things. One point I noted was that there are currently over 600 systems running the famous Weave &lt;a href=&quot;https://microservices-demo.github.io/&quot;&gt;Sock Shop&lt;/a&gt; demonstration App. (Censys Search &lt;a href=&quot;https://search.censys.io/search?resource=hosts&amp;amp;q=%22WeaveSocks+Demo+App%22&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Amusing results aside, there’s a couple of important points which come out of this data. The first one is that it’s quite easy to fingerprint Kubernetes clusters on the Internet, either via distinctive TLS certificates, or exposed API endpoints.&lt;/p&gt;

&lt;p&gt;The second point is the number of companies running unsupported Kubernetes versions exposed to the Internet. These clusters are unlikely to receive security patches, so they could be a single CVE away from compromise.&lt;/p&gt;

&lt;p&gt;In general, from a security standpoint, I’d very much recommend not exposing your API server directly to the Internet unless you really need to. And if you do, make sure you keep it running a supported version of the software!&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Jun 2021 15:00:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/06/05/A-Census-of-Kubernetes-Clusters/</guid>
			</item>
		
			<item>
				<title>Trying out Cosign</title>
				<description>&lt;p&gt;Container image signing has been a bit of a gap in the security landscape, so I’m always interested in seeing new projects starting up which address it. Docker Content Trust/Notary never really gained traction in v1, and whilst v2 looks very interesting, it’s still in the design phase (AFAIK).&lt;/p&gt;

&lt;p&gt;So seeing the &lt;a href=&quot;https://github.com/sigstore/cosign&quot;&gt;Cosign project&lt;/a&gt; come along as part of the &lt;a href=&quot;https://sigstore.dev/&quot;&gt;Sigstore&lt;/a&gt; initiative, I was interested to take a look at it and see how it works. Sigstore has some really interesting ideas about software transparency logs, but for this blog, I’ll just be looking at the raw image signing process.&lt;/p&gt;

&lt;p&gt;The use case I wanted to look at was the idea of getting a container image that’s built as part of a CI pipeline and making a signature available so that people downloading the image from Docker hub could validate that the image they’re downloading was built by me (well more precisely that it was built by someone who had access to the private key which was used to sign it).&lt;/p&gt;

&lt;h2 id=&quot;installing-cosign&quot;&gt;Installing cosign&lt;/h2&gt;

&lt;p&gt;It’s a golang project, so it’s fairly easy to get started, there’s a single binary available from their &lt;a href=&quot;https://github.com/sigstore/cosign/releases/tag/v0.1.0&quot;&gt;release page&lt;/a&gt; and it has been signed by them.&lt;/p&gt;

&lt;p&gt;Once you’ve got it you can generate a keypair &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign generate-key-pair&lt;/code&gt;. A very important point here, is to set a good long passphrase to protect your private key! This will provide you with a public and private key.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-github-actions-to-build-and-sign-your-image&quot;&gt;Setting up Github Actions to build and sign your image.&lt;/h2&gt;

&lt;p&gt;With cosign installed and working, we need get our CI setup to sign the image as it’s built. Cosign have done this with their setup but I wanted to do things a little differently. They put the private key in the repository and I’d prefer to try and keep it a bit more restricted. I’m sure that they’ve set a good passphrase on the key but making it available publicly does open you up to brute force attacks on the passphrase used, so I’d say ideally you’d want to avoid that.&lt;/p&gt;

&lt;p&gt;The test repo I made for this process is &lt;a href=&quot;https://github.com/raesene/cosign_test&quot;&gt;here&lt;/a&gt;. The image itself is just a super simple Dockerfile based on ubuntu 18.04 which adds the cosign binary to it, the interesting part is the GH actions file &lt;a href=&quot;https://github.com/raesene/cosign_test/blob/main/.github/workflows/ci-build-docker-image.yml&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let’s break down what we’re doing in the action. I’m by no means an expert on these, but this seems to work ok :)&lt;/p&gt;

&lt;p&gt;First step is setting up some output with today’s date in this (&lt;a href=&quot;https://github.community/t/how-can-i-set-an-expression-as-an-environment-variable-at-workflow-level/16516/6&quot;&gt;source&lt;/a&gt;). I’m using that to tag the images.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Get current Date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;date&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo &quot;::set-output name=date::$(date +'%Y-%m-%d')&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next we’ll log into my account on Docker hub. For this you’ll need to set a secret in the Github repository with a docker hub access token in it.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Docker login&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo ${{secrets.DOCKER_PASSWORD}} | docker login -u raesene --password-stdin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we’ll build the Docker image and push it to Docker Hub.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;build Docker Image&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker build -t raesene/cosign_test:${{steps.date.outputs.date}} .&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;push to Docker hub&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;docker push raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With our new image on Docker Hub, we need to sign it. One thing I thought about this flow is that it doesn’t really protect against an active malicious Registry as they could theoretically modify my image as soon as it’s uploaded then the sign commands hit afterwards. Pretty niche attack in most cases but could be worth considering.&lt;/p&gt;

&lt;p&gt;What I’ve done in advance of this is get the passphrase protected Cosign private key and place it into a Github Secret called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COSIGN_KEY&lt;/code&gt; . In order to have it available for cosign to read, I put it into a file (using a method from &lt;a href=&quot;https://stackoverflow.com/a/59482124/537897&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;place the cosign private key in a file&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$COSIGN_KEY&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/tmp/cosign.key'&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bash&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;COSIGN_KEY&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.COSIGN_KEY}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now with the signing key available inside the Action, I can sign the image&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Sign the image pushed&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;echo -n &quot;${{secrets.COSIGN_KEY_PASSPHRASE}}&quot; | ./cosign sign -key /tmp/cosign.key raesene/cosign_test:${{steps.date.outputs.date}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One interesting thing, is how cosign stores signatures. If you look on the Docker Hub page for the image that I’m using in the &lt;a href=&quot;https://hub.docker.com/repository/docker/raesene/cosign_test/tags?page=1&amp;amp;ordering=last_updated&quot;&gt;tags tab&lt;/a&gt; you’ll see that cosign creates tags that it uses inside the repo. I think we’ll be seeing more people using OCI registries for things other than pure container images, but this is the first time I’ve seen a tool take that approach.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-image&quot;&gt;Verifying the image&lt;/h2&gt;

&lt;p&gt;Once you’ve got your image uploaded, anyone can use cosign to verify it. For my test image , the public key is&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;-----BEGIN PUBLIC KEY-----&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoeqsxUUhzWrx70u/dCAf1QgBFMVF&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;eyqWrtbAfwDdjONf9gbhfzURQFyZvcL7ET5PEq36x0OS9enJShKzAJKkEQ==&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;-----END PUBLIC KEY-----&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that saved to a file called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign.pub&lt;/code&gt; you should be able to run&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cosign verify &lt;span class=&quot;nt&quot;&gt;-key&lt;/span&gt; cosign.pub raesene/cosign_test:2021-03-21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get output that looks like&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
  - Any certificates were verified against the Fulcio roots.
  - WARNING - THE CERTIFICATE EXPIRY WAS NOT CHECKED. &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COSIGN_EXPERIMENTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 to check!
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Critical&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Identity&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;docker-reference&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Image&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Docker-manifest-digest&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;sha256:9b5a67e1e2e67f60d4e93529ff280f12601586c0c382949f96947001c0c6094f&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Type&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;cosign container signature&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Optional&quot;&lt;/span&gt;:null&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you try verifying a tag that doesn’t have a signature like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invalid&lt;/code&gt; tag on that repository using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosign verify -key cosign.pub raesene/cosign_test:invalid&lt;/code&gt; you’ll get an error&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: GET https://index.docker.io/v2/raesene/cosign_test/manifests/sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign: MANIFEST_UNKNOWN: manifest unknown&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; map[Tag:sha256-45c6f8f1b2fe15adaa72305616d69a6cd641169bc8b16886756919e7c01fa48b.cosign]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s early days for cosign (they just hit 0.1 2 days back), but it along with sigstore, look like a really promising area of tech. Hopefully we’ll see more developments in this area and get some great new ideas for image (and general software) signing.&lt;/p&gt;
</description>
				<pubDate>Sun, 21 Mar 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/03/21/Trying-out-cosign/</guid>
			</item>
		
			<item>
				<title>Getting into a bind with Kubernetes</title>
				<description>&lt;p&gt;Following on from &lt;a href=&quot;https://raesene.github.io/blog/2020/12/12/Escalating_Away/&quot;&gt;looking at the escalate verb in Kubernetes RBAC&lt;/a&gt;, I thought it would be worth looking at another one of the unusual verbs you can see in Kubernetes RBAC, bind.&lt;/p&gt;

&lt;p&gt;These two, along with the impersonate verb are operations that are available on some RBAC objects in the Kubernetes API. They’re quite important if you’re looking at designing or auditing Kubernetes rights as they can allow for privilege escalation, so know which principals have access to them is important.&lt;/p&gt;

&lt;p&gt;The bind verb can be applied to roles or clusterroles and allows a principal to bypass a general restriction on (cluster)role binding creation, which stops users who can create role bindings from escalating their privileges by binding to high privilege roles like cluster admin. This restriction is described in the Kubernetes documentation &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/rbac/#restrictions-on-role-binding-creation-or-update&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The way that this works is that, without using bind, a user cannot create a rolebinding or clusterrolebinding to a role or cluster role which has rights that the user themselves does not currently have. So for example if a user with the rights to create rolebindings tries to bind to cluster-admin , this won’t work unless that user already has cluster-admin rights.&lt;/p&gt;

&lt;p&gt;Bind is made available to allow for this restriction to be bypassed.&lt;/p&gt;

&lt;h2 id=&quot;practical-example&quot;&gt;Practical Example&lt;/h2&gt;

&lt;p&gt;Let’s show a practical example of this. First up we’ll create a couple of service accounts to act as our user for this experiment and we’ll call them &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac-binder&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not-rbac-binder&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now we’ll create a couple of cluster roles. Both have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterrolebindings&lt;/code&gt; but one will also have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterroles&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac-binder&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterroles&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bind&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterrolebindings&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;create&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ClusterRole&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;not-rbac-binder&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;clusterrolebindings&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;create&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we’ll just bind those two clusterroles to their respective service accounts.&lt;/p&gt;

&lt;p&gt;So at this point if we look at our users rights with ` kubectl –as=system:serviceaccount:default:rbac-binder auth can-i –list` we can see that the rbac-binder service account has the following rights&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Resources                                       Non-Resource URLs   Resource Names   Verbs
clusterroles.rbac.authorization.k8s.io          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
selfsubjectaccessreviews.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
selfsubjectrulesreviews.authorization.k8s.io    &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
clusterrolebindings.rbac.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api]              &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis]             &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and the not-rbac-binder service account has these rights&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:not-rbac-binder auth can-i &lt;span class=&quot;nt&quot;&gt;--list&lt;/span&gt;
Resources                                       Non-Resource URLs   Resource Names   Verbs
selfsubjectaccessreviews.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
selfsubjectrulesreviews.authorization.k8s.io    &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
clusterrolebindings.rbac.authorization.k8s.io   &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                  &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;create]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/api]              &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/apis]             &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/healthz]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/livez]            &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/openapi]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/readyz]           &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version/]         &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
                                                &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/version]          &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;get]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now if we try to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not-rbac-binder&lt;/code&gt; to create a clusterrolebinding to cluster-admin, it will fail with the following error message (remember here that we do have create clusterrolebinding rights).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:not-rbac-binder create clusterrolebinding rbac-clusteradmin &lt;span class=&quot;nt&quot;&gt;--clusterrole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&quot;nt&quot;&gt;--serviceaccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;namespace:not-rbac-binder
error: failed to create clusterrolebinding: clusterrolebindings.rbac.authorization.k8s.io &lt;span class=&quot;s2&quot;&gt;&quot;rbac-clusteradmin&quot;&lt;/span&gt; is forbidden: user &lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccount:default:not-rbac-binder&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccounts&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;system:serviceaccounts:default&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;system:authenticated&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; is attempting to grant RBAC permissions not currently held:
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;APIGroups:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Resources:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Verbs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;NonResourceURLs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, Verbs:[&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then if we try the same operation with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac-binder&lt;/code&gt; it works!&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl &lt;span class=&quot;nt&quot;&gt;--as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;system:serviceaccount:default:rbac-binder create clusterrolebinding rbac-clusteradmin &lt;span class=&quot;nt&quot;&gt;--clusterrole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&quot;nt&quot;&gt;--serviceaccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;namespace:rbac-binder
clusterrolebinding.rbac.authorization.k8s.io/rbac-clusteradmin created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The bind verb on RBAC is a useful piece of Kubernetes RBAC configuration but it’s also a lesser known are of RBAC and one which not all tools might properly understand. As it can allow for privilege escalation, it’s an important thing to check for when creating or auditing roles and clusterroles.&lt;/p&gt;
</description>
				<pubDate>Sat, 16 Jan 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/01/16/Getting-Into-A-Bind-with-Kubernetes/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/01/16/Getting-Into-A-Bind-with-Kubernetes/</guid>
			</item>
		
			<item>
				<title>Kubernetes is a router</title>
				<description>&lt;p&gt;One of the interesting areas of Kubernetes to explore is how it handles networking, and this is a quick post looking at one assumption which can be made about Kubernetes networking and how it doesn’t always hold. Whilst Kubernetes can assign pod IP addresses on the same LAN as the host VM, it’s more normal for the CNI to hand out IP addresses from a separate range, and then implement some kind of overlay networking between the cluster nodes to get traffic from pods on one node, to pods on other nodes. As part of this duty, Kubernetes nodes will often act as routers, so if you can get traffic to the node they’ll happily forward it on.&lt;/p&gt;

&lt;p&gt;This could leave you with the idea that pods aren’t accessible from elsewhere on the LAN that the cluster lives on, which could in turn provide a false sense of security about their accessibility, so it’s important to know that whilst pods aren’t usually accessible, that’s not a security feature.&lt;/p&gt;

&lt;p&gt;To demonstrate this I setup a single node Kubeadm cluster and a client machine on the same LAN. In this setup the cluster node is at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.134&lt;/code&gt; and the client at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.135&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the cluster node if I do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get po -A -o wide&lt;/code&gt; we can see the pod IP addresses for the pods running in the cluster :-&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAMESPACE         NAME                                       READY   STATUS    RESTARTS   AGE   IP                NODE      
calico-system     calico-kube-controllers-546d44f5b7-gchk4   1/1     Running   1          16h   10.8.203.8        kubeadm120
calico-system     calico-node-475ff                          1/1     Running   1          16h   192.168.197.134   kubeadm120
calico-system     calico-typha-54879db669-6m4pr              1/1     Running   1          16h   192.168.197.134   kubeadm120
default           testweb                                    1/1     Running   1          16h   10.8.203.7        kubeadm120
kube-system       coredns-74ff55c5b-pp2kt                    1/1     Running   1          16h   10.8.203.6        kubeadm120
kube-system       coredns-74ff55c5b-x8fzx                    1/1     Running   1          16h   10.8.203.5        kubeadm120
kube-system       etcd-kubeadm120                            1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-apiserver-kubeadm120                  1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-controller-manager-kubeadm120         1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-proxy-kkb2v                           1/1     Running   1          16h   192.168.197.134   kubeadm120
kube-system       kube-scheduler-kubeadm120                  1/1     Running   1          16h   192.168.197.134   kubeadm120
tigera-operator   tigera-operator-657cc89589-624rj           1/1     Running   2          16h   192.168.197.134   kubeadm120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Whilst some of them (the ones using host networking) are on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.197.0/24&lt;/code&gt; network, some of the others are on the pod network of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.8.0.0/16&lt;/code&gt; which was configured when I setup the cluster. So, from my client machine, I can’t immediately address services on the pod network. If I try to access the nginx web server on the “testweb” pod, it won’t work, as my client doesn’t know how to route traffic to it.&lt;/p&gt;

&lt;p&gt;However, like the post title says, Kubernetes is a router, so if I can add a route on my client, telling it that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.8.0.0/16&lt;/code&gt; network can be reached via the Kubernetes cluster node, I can get traffic to it!&lt;/p&gt;

&lt;p&gt;This is easily enough done, just add a route like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo route add -net 10.8.0.0 netmask 255.255.0.0 gw 192.168.197.134&lt;/code&gt; and then bingo, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl http://10.8.203.7&lt;/code&gt; will return our nginx container’s home page.&lt;/p&gt;

&lt;h2 id=&quot;why-does-that-work&quot;&gt;Why does that work?&lt;/h2&gt;

&lt;p&gt;So we can then look a bit into why this works. The first part is routing. If we look at the routing table on our cluster node we can see routes for our pods. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;route -n&lt;/code&gt; shows :-&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.197.2   0.0.0.0         UG    100    0        0 ens33
10.8.203.5      0.0.0.0         255.255.255.255 UH    0      0        0 cali8c667e24141
10.8.203.6      0.0.0.0         255.255.255.255 UH    0      0        0 calib967dfbd495
10.8.203.7      0.0.0.0         255.255.255.255 UH    0      0        0 calib9199d171be
10.8.203.8      0.0.0.0         255.255.255.255 UH    0      0        0 calie65c0ecd96a
10.8.203.9      0.0.0.0         255.255.255.255 UH    0      0        0 cali68caf03a5f4
10.8.203.10     0.0.0.0         255.255.255.255 UH    0      0        0 cali78a7a37ae9d
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
192.168.197.0   0.0.0.0         255.255.255.0   U     0      0        0 ens33
192.168.197.2   0.0.0.0         255.255.255.255 UH    100    0        0 ens33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we know the node has a route for the pods which is local as there’s no “G” flag on it. The other part of the equation is packet forwarding. Checking the standard Linux sysctl for this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysctl net.ipv4.ip_forward&lt;/code&gt; we can see that packet fowarding is enabled&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net.ipv4.ip_forward &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So traffic sent to the kubernetes node will be forwarded, based on its routing table, and will get to the pod ok.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a relatively minor point, but one worth remembering, just because you can’t get access to pod IP addresses from outside the cluster by default, it’s not a security barrier you should be relying on. In general services running in pods on the cluster should be secured, just like any other service running in your network as they are likely to be accessible in one way or another. If you do want to restrict access to pods running in a cluster, using &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/network-policies/&quot;&gt;network policies&lt;/a&gt; will be the way to go.&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jan 2021 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2021/01/03/Kubernetes-is-a-router/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2021/01/03/Kubernetes-is-a-router/</guid>
			</item>
		
			<item>
				<title>Exploring Rootless Docker</title>
				<description>&lt;p&gt;With the release of Docker 20.10, the rootless containers feature has left experimental status. This is an important step for Docker security as it allows for the entire Docker installation to run with standard user prvivileges, no use of root required. Other container solutions like Podman have had this feature for a while but if your used to Docker’s approach it’s nice to see it being available.&lt;/p&gt;

&lt;p&gt;Docker’s documentation on &lt;a href=&quot;https://docs.docker.com/engine/security/rootless/&quot;&gt;rootless containers&lt;/a&gt; has some information about how this is achieved, but I thought it’d be interesting to have a poke around some of the details of the implementation and what it means for container security, especially as I’ll be adding this to the container security course I do.&lt;/p&gt;

&lt;h2 id=&quot;install-and-use&quot;&gt;Install and Use&lt;/h2&gt;

&lt;p&gt;Setting up rootless containers is pretty straightforward, on Ubuntu at least. You need a couple of packages to be installed (the main one you’ll likely need to add is uidmap) and then you can use Docker’s install script to set it up. Obviously I’d recommend downloading and reading the script rather than following their suggestion to pipe it straight to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sh&lt;/code&gt; but looking through it you’ll see it’s mainly just checking the environment before setting up and then downloading and extracting the necessary binaries to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/bin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once it’s installed and you tell the docker CLI where to find the socket file (in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/run/user/UID/docker.sock&lt;/code&gt; instead of the usual &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/run/docker.sock&lt;/code&gt; ) you can start using Docker. The general use case is pretty much exactly what you’d expect, docker commands work fine, you can pull and run images, execute shells in them, and do most of the other things you’d usually do.&lt;/p&gt;

&lt;p&gt;A couple of limitations are present, specifically no cgroups support, unless you enabled cgroupsv2 at the host level and no use of ping or ports &amp;lt; 1024, but again these can be configured if needed. I’d expect the primary use case for rootless docker to be on shared development boxes and perhaps CI hosts, so these limitations probably are deal breakers and in both cases simple configuration options are available.&lt;/p&gt;

&lt;h2 id=&quot;exploring-under-the-covers&quot;&gt;Exploring under the covers&lt;/h2&gt;

&lt;p&gt;So what’s going on here, and how does it compare to standard Docker.&lt;/p&gt;

&lt;h3 id=&quot;user-namespaces&quot;&gt;User namespaces&lt;/h3&gt;

&lt;p&gt;One of the common security challenges when using containes is that they often run as the root user (uid 0) on the host. Whilst Docker has various layers of security to reduce the risk of this, it’s still a cause of potential security problems.&lt;/p&gt;

&lt;p&gt;So now we’re running Docker without any root acccess, what happens?&lt;/p&gt;

&lt;p&gt;With rootless docker setup, if we do something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name=rootlessweb -d nginx&lt;/code&gt; to start up a container, then run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec rootlessweb whoami&lt;/code&gt; , you’ll get back the answer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;, which shows that the container thinks it’s running as root.&lt;/p&gt;

&lt;p&gt;To see what’s really happening, we can get the PID of the container with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker inspect -f '{{.State.Pid}}' rootlessweb&lt;/code&gt; and then look for that process ID in the output of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef&lt;/code&gt;. What you’ll see is that instead of running as root, it’s running as your user!&lt;/p&gt;

&lt;p&gt;The way this is being done is through the use of &lt;a href=&quot;https://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;user namespaces&lt;/a&gt; which have been available in Docker (but rarely used) for quite some time. Docker is mapping uids inside the container, to different uids outside the container (which is why it needed the uidmap package installed). This allows the contained process to act as though it had root rights, without it actually having root rights to the underlying machine.&lt;/p&gt;

&lt;p&gt;Obviously from a security standpoint this is a big positive as it means that kernel bugs that need real &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uid 0&lt;/code&gt; to work, will be blocked as, from the perspective of the kernel, the process is unprivileged.&lt;/p&gt;

&lt;h2 id=&quot;capabilities&quot;&gt;Capabilities&lt;/h2&gt;

&lt;p&gt;One of the things Docker does as part of its setup is use various layers of isolation on contained processes. One of those layers is capabilities. With this one, you might think it’s not going to apply to rootless containers as capabilities are often described as “piece of root rights” which don’t apply here.&lt;/p&gt;

&lt;p&gt;However, reading the user namespace manpages, we can see that actually capabilities are still used inside user namespaces to restrict access. The important part to remember from a security standpoint is that capabilities in user namespaces can only grant rights to resources governed by that namespace. So having CAP_SYS_ADMIN in a user namespace will get you rights in that namespace, but not rights over the underlying host kernel.&lt;/p&gt;

&lt;p&gt;We can see the capability setup by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pscap&lt;/code&gt; on a host running rootless containers. For example the nginx container from the previous example will look like this&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;8198  8219  rorym       nginx             &lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt;, dac_override, fowner, fsetid, &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt;, setgid, setuid, setpcap, net_bind_service, net_raw, sys_chroot, &lt;span class=&quot;nb&quot;&gt;mknod&lt;/span&gt;, audit_write, setfcap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;apparmor&quot;&gt;AppArmor&lt;/h2&gt;

&lt;p&gt;This one is not supported under rootless containers, so no profiles will be loaded (unlike standard rootful containers).&lt;/p&gt;

&lt;h2 id=&quot;seccomp-filter&quot;&gt;Seccomp filter&lt;/h2&gt;

&lt;p&gt;The standard Docker seccomp filter is enabled when using rootless containers, which you can see by inspecting the proc status for our contained process with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /proc/[PID]/status | grep Seccomp&lt;/code&gt; which should return a value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; showing there’s a seccomp profile applied.&lt;/p&gt;

&lt;h2 id=&quot;container-breakout&quot;&gt;Container breakout&lt;/h2&gt;

&lt;p&gt;So now we’ve looked at the various layers of isolation that are used in docker and how they apply (or don’t) to rootless containers, lets look at some of the practical tools and techniques and what they return when run in a rootless container.&lt;/p&gt;

&lt;h3 id=&quot;the-most-pointless-docker-command-ever&quot;&gt;The most pointless docker command ever&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/&quot;&gt;My favourite docker command&lt;/a&gt; is a good place to start. Running&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-ti&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--privileged&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--ipc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;nt&quot;&gt;--volume&lt;/span&gt; /:/host busybox &lt;span class=&quot;nb&quot;&gt;chroot&lt;/span&gt; /host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Generates an error. Both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--pid=host&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--ipc=host&lt;/code&gt; don’t work with rootless containers, after removing those we get dropped to a root shell with access to what &lt;em&gt;looks like&lt;/em&gt; the root filesystem of the underlying host. Trying to modify things, however, shows we’re not in the real root filesystem. We can add files in system directories like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc&lt;/code&gt; , however exiting the container shows that the files haven’t actually been created, so it’s obvious that our volume mount didn’t have the effect it would have had, if we had been running a rootful container.&lt;/p&gt;

&lt;h3 id=&quot;amicontained&quot;&gt;amicontained&lt;/h3&gt;

&lt;p&gt;Running &lt;a href=&quot;https://github.com/genuinetools/amicontained&quot;&gt;amicontained&lt;/a&gt; from inside a rootless container shows that it’s easy to detect that we’re in a user namespace, and indeed information is available about how UIDs are being mapped inside the container&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Container Runtime: docker
Has Namespaces:
        pid: &lt;span class=&quot;nb&quot;&gt;true
        &lt;/span&gt;user: &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;User Namespace Mappings:
        Container -&amp;gt; 0  Host -&amp;gt; 1000    Range -&amp;gt; 1
        Container -&amp;gt; 1  Host -&amp;gt; 100000  Range -&amp;gt; 65536
AppArmor Profile: unconfined
Capabilities:
        BOUNDING -&amp;gt; &lt;span class=&quot;nb&quot;&gt;chown &lt;/span&gt;dac_override fowner fsetid &lt;span class=&quot;nb&quot;&gt;kill &lt;/span&gt;setgid setuid setpcap net_bind_service net_raw sys_chroot &lt;span class=&quot;nb&quot;&gt;mknod &lt;/span&gt;audit_write setfcap
Seccomp: filtering
Blocked Syscalls &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
        MSGRCV SYSLOG SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES FUTIMESAT UNSHARE MOVE_PAGES UTIMENSAT PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PKEY_MPROTECT PKEY_ALLOC PKEY_FREE IO_PGETEVENTS RSEQ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;botb&quot;&gt;botb&lt;/h3&gt;

&lt;p&gt;Using &lt;a href=&quot;https://github.com/brompwnie/botb&quot;&gt;botb&lt;/a&gt; to try and autopwn out of a container that has the docker socket mounted runs us into a problem, which is that it tries to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--pid=host&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--ipc=host&lt;/code&gt; as part of the breakout.&lt;/p&gt;

&lt;p&gt;This is, in general, a possibly interesting point about container breakout tools, as they’re unlikely to take account of rootless containers.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Rootless containers are a great addition to Docker’s repetoire. In situations where you want to have users run docker commands without giving the root access to the underlying host, this will really help out. The setup and usuability are great, but you need to take account of the fact that certain things just won’t work the same way as functions reserved for the root user on the host machine won’t be usuable.&lt;/p&gt;
</description>
				<pubDate>Sat, 19 Dec 2020 16:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/12/19/rootless_docker/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/12/19/rootless_docker/</guid>
			</item>
		
			<item>
				<title>Escalating Away</title>
				<description>&lt;p&gt;Following a recent run of the container security training course I do, I was poking around a bit with the escalate verb in Kubernetes RBAC and found some interesting points, so thought it’d be worth documenting, as it’s not necessarily the best known part of RBAC.&lt;/p&gt;

&lt;p&gt;The reason we were interested in the escalate verb is to answer the question “If I can get secrets in a standard kubeadm cluster, what are my options for escalating my privileges to cluster-admin?”. This question used to be pretty straightforward as until last year there was a service account in the kube-system namespace which had cluster-admin rights, so you could easily get its secret and be cluster-admin. The service account in question is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clusterrole-aggregation-controller&lt;/code&gt;. However last year the rights on this service account got changed (at least in part as I pointed it out). From &lt;a href=&quot;https://github.com/kubernetes/kubernetes/commit/8b155e82d876c8130962e61b2235f2bd066abde1&quot;&gt;the commit&lt;/a&gt; you can see that the cluster-admin rights were replaced with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;escalate&lt;/code&gt; rights on cluster roles.&lt;/p&gt;

&lt;p&gt;So that leads to the question, “how can I use this permission?”. Unlike the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;impersonate&lt;/code&gt; verb, there’s no handy kubectl flags to add to instantly escalate your rights. So I was looking for information on the topic (which is pretty sparse) and found this &lt;a href=&quot;https://www.impidio.com/blog/kubernetes-rbac-security-pitfalls&quot;&gt;interesting blog post&lt;/a&gt;, which led to the answer.&lt;/p&gt;

&lt;p&gt;What escalate does is bypass the Kubernetes RBAC check which prevents users who are able to create roles or cluster roles from creating (or editing) these objects to have more rights than they do. So what we can do, once we have the service account token for the clusterrole-aggregation-controller is to edit our own cluster role to increase our permissions?&lt;/p&gt;

&lt;p&gt;We can run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl edit clusterrole system:controller:clusterrole-aggregation-controller&lt;/code&gt; and then edit it to add this to the rules section&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and away you go!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;escalate&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;impersonate&lt;/code&gt; are lesser known features of RBAC but one that you should be aware of if you’re a systems administrator or if you’re looking at security tooling around Kubernetes.&lt;/p&gt;
</description>
				<pubDate>Sat, 12 Dec 2020 13:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/12/12/Escalating_Away/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/12/12/Escalating_Away/</guid>
			</item>
		
			<item>
				<title>The revenge of system:masters, return of the AKS</title>
				<description>&lt;p&gt;When looking at an AKS cluster recently, I came across some unusual default behaviour, which I thought deserved some more investigation over the weekend. Seems like AKS is making some … interesting… choices with regards to user authentication, in some setups.&lt;/p&gt;

&lt;p&gt;Usually when you authenticate to an Azure AD (AAD) enabled AKS cluster it uses OAuth with a short renewal window for credentials, which is great as it leverages the Azure AD authentication process and has a nice short expiry to reduce the risk of a misplaced kubeconfig file.&lt;/p&gt;

&lt;p&gt;However there’s an option on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;az aks get-credentials&lt;/code&gt; command which acts a bit differently. If you pass &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--admin&lt;/code&gt; to that command, instead of using OAuth, it adds a client certificate file to your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubeconfig&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Client certificate authentication in Kubernetes is a bit problematic for a number of reasons, the main one being that there is &lt;strong&gt;no way&lt;/strong&gt; to revoke a credential once it’s issued (short of rolling the keys for the whole certificate authority), that means it’s generally unsuitable for any production cluster and definitely production clusters used by large organizations.&lt;/p&gt;

&lt;p&gt;However digging into the client cert issued by AKS, things get worse. If you decode it (the one below is from a sample AKS cluster I set-up using the standard &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough&quot;&gt;AKS QuickStart&lt;/a&gt;), you’ll see something like this&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Validity
   Not Before: Nov 28 20:11:59 2020 GMT
   Not After : Nov 28 20:21:59 2022 GMT
   Subject: O &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; system:masters, CN &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; masterclient
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The way that Kubernetes client certificate authentication works, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CN&lt;/code&gt; field is considered the username and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O&lt;/code&gt; field is the group the user belongs to, so this is logging in with a username of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;masterclient&lt;/code&gt; and a group of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:masters&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First problem is the username. That’s not the name of the user I used to login, this is a generic username. That means that any actions taken by this credential will show up with a generic username not matter who uses it, bit of a problem for auditing.&lt;/p&gt;

&lt;p&gt;The second problem is the group name. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system:masters&lt;/code&gt; is a special group in Kubernetes, its access as a cluster-admin is hardcoded into the Kubernetes source code and there’s no way to remove those rights, so this credential will always have cluster-admin rights.&lt;/p&gt;

&lt;p&gt;The third problem is the expiry, which is 2 years from cluster setup. So anyone with this credential has a generic cluster-admin level login which can’t be revoked (short of rolling the entire certifiicate authority used for the cluster) and can’t be audited, which lasts for up to two years.&lt;/p&gt;

&lt;p&gt;Another surprising thing I noticed was that, in non-AAD enabled clusters, users with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Azure Kubernetes Service Cluster User Role&lt;/code&gt; get this same certificate given to them when they use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;az aks get-credentials&lt;/code&gt; even without the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--admin&lt;/code&gt; switch! This is a &lt;a href=&quot;https://github.com/Azure/AKS/issues/1343&quot;&gt;known issue&lt;/a&gt; with AKS…&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;A couple of takeaways if your organization is planning to use Azure AKS. First up if your clusters are AAD enabled, be &lt;strong&gt;very&lt;/strong&gt; careful with who has rights to used the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--admin&lt;/code&gt; switch on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get-credentials&lt;/code&gt; command. Secondly, I’d recommend not exposing your clusters directly on the Internet to reduce the likely impact of this.&lt;/p&gt;

&lt;p&gt;If you’re using non-AAD enabled clusters, it’s worth noting that all your users may be using generic cluster-admin credentials, so you should check the generated kubeconfig files and plan for that.&lt;/p&gt;
</description>
				<pubDate>Sun, 29 Nov 2020 11:00:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/11/29/The_revenge_of_system_masters/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/11/29/The_revenge_of_system_masters/</guid>
			</item>
		
			<item>
				<title>When is a Vulnerability (possibly) not a vulnerability</title>
				<description>&lt;p&gt;Over the last couple of months I’ve been looking at container vulnerability scanning a bit (some more info &lt;a href=&quot;https://raesene.github.io/blog/2020/06/21/Container_Vulnerability_Scanning_Fun/&quot;&gt;here&lt;/a&gt;), and there  was one behaviour I noticed that’s probably worth commenting on, as it can be a bit unexpected, and that’s the handling of unfixed vulnerbilities.&lt;/p&gt;

&lt;p&gt;Some Linux distributions (e.g. Debian or Ubuntu) will release information about CVEs for which there is no released patched package, and so you get the question of “should a vulnerability scanner report those?”. On the one hand, it’s good for organizations to know about all their vulnerabilities. On the other hand, from a compliance standpoint, having a large number of unpatchable vulnerabilities can be awkward!&lt;/p&gt;

&lt;p&gt;Whilst this behaviour isn’t unique to containers, I came across it when investigating the differences between the results of different container scanning engines when run against Docker Hub official images. Some tools, for example Nessus and Nexpose would report 0 issues, whilst others, such as Trivy or Clair would report relatively large numbers. As far as I can tell, what’s happening is that Nessus/Nexpose take the approach of not flagging unpatched vulnerabilities where Trivy and Clair default to flagging them.&lt;/p&gt;

&lt;p&gt;I was wondering how to replicate this as Nessus’ container scanning service is not availble for free, however luckily you can use Trivy to scan a Virtual Machine image, so we can test it that way and use the free Nessus Essentials for comparison. For this test, I got an Ubuntu 18.04 server image, updated it fully and ran Nessus and Trivy against it.&lt;/p&gt;

&lt;p&gt;A Nessus scan using credentials to allow patch checking, showed 0 unpatched vulnerabilities. Trivy by default showed 242 vulnerabilities as shown below.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;trivy fs &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /
2020-11-21T21:16:57.492Z        INFO    Detecting Ubuntu vulnerabilities...

trivyubu &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ubuntu 18.04&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt;
Total: 242 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;UNKNOWN: 0, LOW: 178, MEDIUM: 64, HIGH: 0, CRITICAL: 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helpfully, Trivy provides an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--ignore-unfixed&lt;/code&gt; option, which demonstrates that what we’re seeing is unpatched issues, as with that flag we get back 0.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rorym@trivyubu:~/trivy_output&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;trivy fs &lt;span class=&quot;nt&quot;&gt;--ignore-unfixed&lt;/span&gt; /
2020-11-21T21:17:16.931Z        INFO    Detecting Ubuntu vulnerabilities...

trivyubu &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ubuntu 18.04&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt;
Total: 0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;UNKNOWN: 0, LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So the question is, which one’s right? I’d say (like most things in security) that depends! For most organizations, you probably don’t want to manually patch and compile packages, so you may want to use a container scanner that supports functionality to ignore unfixed issues. This also gives you comparable scanning to the output you’re likely getting from your Virtual Machine vulnerability scanning efforts.&lt;/p&gt;

&lt;p&gt;For higher risk deployments, you might want to review the package lists and ensure that you’re comfortable leaving those issues unpatched.&lt;/p&gt;

&lt;p&gt;Of course, mitigations like minimizing the number of installed packages and looking at distroless or scratch containers, could also help reduce this kind of problem.&lt;/p&gt;
</description>
				<pubDate>Sun, 22 Nov 2020 11:10:39 +0000</pubDate>
				<link>https://raesene.github.io/blog/2020/11/22/When_Is_A_Vulnerability_Not_A_Vulnerability/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/11/22/When_Is_A_Vulnerability_Not_A_Vulnerability/</guid>
			</item>
		
			<item>
				<title>Container Vulnerability Scanning Fun</title>
				<description>&lt;p&gt;Vulnerability Assessment is one of those foundational IT Security tasks that often gets overlooked or thought to be reasonably straightforward, where you can actually find some interesting complications that make it trickier than expected.&lt;/p&gt;

&lt;p&gt;Generally, most companies will include VA as part of their overall operational security processes, looking to assure that the software they’re deploying is relatively free of unpatched security vulnerabilities.&lt;/p&gt;

&lt;p&gt;This post will look a bit at how assessing vulnerabilities of container images for outdated operating system packages is handled and some things to be aware of. We’ll exclude Windows container images to keep things (relatively) straightforward and stick to operating system level vulnerabilities.&lt;/p&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;Most Docker images are based on specific Linux distributions and make use of the package managers that those distributions provide to deploy software like tooling and libraries that support the application running in containers based on that image.&lt;/p&gt;

&lt;p&gt;So if we’re looking to assess whether there are known vulnerabilities in our images, it would seem possible to use the data provided by the distributions about package versions and CVEs that are patched in them, to assess whether a given image has unpatched vulnerabilities, so far … so simple!&lt;/p&gt;

&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;/h2&gt;

&lt;p&gt;To take a practical look at how this works, we can use some of the Open Source container vulnerability scanning tools that are available.  For this post we’ll look at three&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/anchore/anchore-engine&quot;&gt;Anchore Engine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/quay/clair&quot;&gt;Clair&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/aquasecurity/trivy&quot;&gt;Trivy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the examples below, I set up all three scanners to run locally (e.g. without setting up a container registry).  For Anchore I used their Docker compose file and &lt;a href=&quot;https://github.com/anchore/anchore-cli&quot;&gt;Ancore CLI&lt;/a&gt;, for clair I used &lt;a href=&quot;https://github.com/arminc/clair-local-scan&quot;&gt;clair-local-scan&lt;/a&gt; and for Trivy, I just used the binary as it comes from their repo. A side note on these is that, from the perspective of setup processes for standalone usage, Trivy is by far the easiest to get working.&lt;/p&gt;

&lt;h2 id=&quot;scanning-common-base-images&quot;&gt;Scanning Common Base Images&lt;/h2&gt;

&lt;p&gt;So now we’ve got three scanners setup, let’s take a look at some common base images and see what they come up with. All three tools provide a JSON output option, so we can use that to create parseable results for analysis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you don’t want to read down a couple of points to note&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Despite the task seeming relatively simple, even in base images different container vulnerability scanners produce quite different results&lt;/li&gt;
  &lt;li&gt;The scanning engines support different sets of base images, so that should be noted when you’re assessing which one to use&lt;/li&gt;
  &lt;li&gt;Even in a fully updated base image, there can still be outstanding CVEs, depending on the update cycle of both Docker Hub and the underlying distribution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Summary of Vulnerability Numbers&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Ubuntu:18.04&lt;/th&gt;
      &lt;th&gt;Ubuntu:20.04&lt;/th&gt;
      &lt;th&gt;Debian:stable&lt;/th&gt;
      &lt;th&gt;Centos:8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Anchore&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Clair&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;89&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Trivy&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;result-details&quot;&gt;Result Details&lt;/h1&gt;

&lt;h2 id=&quot;ubuntu1804&quot;&gt;Ubuntu:18.04&lt;/h2&gt;

&lt;p&gt;This is a very commonly used base image.  We’re using the latest version with that tag from Docker Hub.  First question is, when we scan this image, how many vulnerabilities does each scanner think we have?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Count&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore thinks the vuln count is : 71
Clair thinks the vuln count is : 38
Trivy thinks the vuln count is : 73
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is moderately interesting already.  If you’re using an updated image from Docker Hub, you might think there would be no unpatched issues, but you’d be wrong. One interesting piece about these issue counts is that (in this case) it turns out that the CVEs referenced are the same but that some of the scanners have multiple vulnerabilities for a single CVE.&lt;/p&gt;

&lt;p&gt;Next question, what severity do the various scanners apply to these vulnerabilities&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Severities&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Low&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;31, &lt;span class=&quot;s2&quot;&gt;&quot;Negligible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;23, &lt;span class=&quot;s2&quot;&gt;&quot;Medium&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;17&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Clair Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Medium&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;11, &lt;span class=&quot;s2&quot;&gt;&quot;Low&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;20, &lt;span class=&quot;s2&quot;&gt;&quot;Negligible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;7&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Trivy Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LOW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;55, &lt;span class=&quot;s2&quot;&gt;&quot;MEDIUM&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;18&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some relatively major differences there too.&lt;/p&gt;

&lt;h2 id=&quot;ubuntu2004&quot;&gt;Ubuntu:20.04&lt;/h2&gt;

&lt;p&gt;Lets try the newest stable release of Ubuntu and see what that shows up. Here, Clair doesn’t notice any issues whilst both Anchore and Trivy report over twenty&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Count&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore thinks the vuln count is : 23
Clair thinks the vuln count is : 0
Trivy thinks the vuln count is : 26
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On severities, Trivy includes a high, where all of Anchore’s severities are medium or low.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Severities&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Low&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;11, &lt;span class=&quot;s2&quot;&gt;&quot;Negligible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;5, &lt;span class=&quot;s2&quot;&gt;&quot;Medium&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;7&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Clair Severity Counts : &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
Trivy Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;MEDIUM&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;9, &lt;span class=&quot;s2&quot;&gt;&quot;LOW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;16, &lt;span class=&quot;s2&quot;&gt;&quot;HIGH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;debianstable&quot;&gt;Debian:stable&lt;/h2&gt;

&lt;p&gt;Here the numbers are switched around again with Clair and Trivy reporting quite a few more issues than Anchore. An interesting point is that whilst Clair and Trivy’s total vulnerability counts are similar, the referenced CVEs have quite a few differences.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Count&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore thinks the vuln count is : 47
Clair thinks the vuln count is : 89
Trivy thinks the vuln count is : 88
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability severity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Negligible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;46, &lt;span class=&quot;s2&quot;&gt;&quot;Medium&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Clair Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Low&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;21, &lt;span class=&quot;s2&quot;&gt;&quot;Negligible&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;45, &lt;span class=&quot;s2&quot;&gt;&quot;Unknown&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;23&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Trivy Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LOW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;69, &lt;span class=&quot;s2&quot;&gt;&quot;MEDIUM&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;17, &lt;span class=&quot;s2&quot;&gt;&quot;HIGH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;centos8&quot;&gt;Centos:8&lt;/h2&gt;

&lt;p&gt;Another commonly used base image here the results are interesting, in that Trivy doesn’t recognize the OS at all and Anchore comes out with a lot more vulnerabilities than Clair.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Count&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore thinks the vuln count is : 74
Clair thinks the vuln count is : 1
Trivy thinks the vuln count is : 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Vulnerability Severities&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Anchore Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Low&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;23, &lt;span class=&quot;s2&quot;&gt;&quot;High&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;4, &lt;span class=&quot;s2&quot;&gt;&quot;Medium&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;47&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Clair Severity Counts : &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;High&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Trivy Severity Counts : &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
				<pubDate>Sun, 21 Jun 2020 16:10:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2020/06/21/Container_Vulnerability_Scanning_Fun/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/06/21/Container_Vulnerability_Scanning_Fun/</guid>
			</item>
		
			<item>
				<title>Custom Pentest Distributions using WSL2</title>
				<description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;So with the release of Windows 20.04 over the last week, we’ve finally got the opportunity to use WSL2 without being subscribed to Windows Insider.  After upgrading and getting WSL2 setup, I started thinking about how I could use this as part of my standard pentesting workflow.&lt;/p&gt;

&lt;p&gt;One good practice for pentesting is to create a clean environment for every test you do, to avoid data from one test getting picked up in another and to keep your tooling versions clean. Tools like Ansible are very handy for the packaging piece, I’ve got some playbooks for adding container security tooling to an Ubuntu setup &lt;a href=&quot;https://github.com/raesene/container_sec_workstation&quot;&gt;on GitHub&lt;/a&gt;, but that still leaves the creation of the base install.  Also another challenge can be integrating your pentest environment with your main system.&lt;/p&gt;

&lt;p&gt;With these challenges in mind it seemed like WSL2 could make things easier by providing lightweight virtualized environments with good integration with a Windows host.  What we’ll need however is a way to create “template” WSL2 instances.  By default with WSL and WSL2 you install distributions from the Windows store, but that doesn’t quite fit our use case as what I’m looking to do here is create a new one per test.&lt;/p&gt;

&lt;p&gt;Luckily WSL2 is pretty flexible and we can work round this easily. The steps below are based on the process in &lt;a href=&quot;https://winaero.com/blog/export-import-wsl-linux-distro-windows-10/&quot;&gt;this blog&lt;/a&gt;.  From that we can see that it’s possible to import and export root filesystems to create WSL distributions (kind of the same way you can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--export&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--import&lt;/code&gt; in Docker)&lt;/p&gt;

&lt;h1 id=&quot;creating-a-custom-distribution&quot;&gt;Creating a Custom Distribution&lt;/h1&gt;

&lt;p&gt;The first thing we’ll need is a root filesystem.  Luckily Ubuntu make their WSL root filesystem available for download, which is availble &lt;a href=&quot;https://cloud-images.ubuntu.com/releases/focal/release/ubuntu-20.04-server-cloudimg-amd64-wsl.rootfs.tar.gz&quot;&gt;here&lt;/a&gt;. For this walkthrough I’ve created a directory on my Windows C: drive called “WSL”, we’ll place the rootfs files in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c:\WSL\wslrootfs&lt;/code&gt; and the distros in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c:\WSL\wsldistros\&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Download the file above to the wslrootfs directory.&lt;/li&gt;
  &lt;li&gt;Run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsl.exe --import baseubu C:\wsl\wsldistros\baseubu\ C:\wsl\wslrootfs\ubuntu-20.04-server-cloudimg-amd64-wsl.rootfs.tar.gz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;baseubu&lt;/code&gt; Is just a name you want to assign so for example a specific project. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c:\wsl\wsldistros\baseubu\&lt;/code&gt; is the directory on your machine you want to place the virtual disk file for the distribution and then we have the distro file we downloaded&lt;/p&gt;

&lt;p&gt;At this point you have a clean install of ubuntu 20.04 to use. You can then easily access each distribution you have available with Windows Terminal which places them all on a tab drop-down for easy access.&lt;/p&gt;

&lt;h1 id=&quot;adding-docker-into-our-distribution&quot;&gt;Adding Docker into our distribution&lt;/h1&gt;

&lt;p&gt;If you’ve got &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker for Windows&lt;/a&gt; installed, you can also easily integrate it into this environment, so you can get all your favourite container based goodies working.  To do this, go into Docker’s settings, go to Resources–&amp;gt; WSL Integration.  You’ll see a list of your distributions, including the one you’ve just imported.  Flick the slider next to it to “on” , then click “apply and restart” and all your docker commands should work just fine then next time you start a session with that distro.&lt;/p&gt;

&lt;h1 id=&quot;visual-studio-code-integration&quot;&gt;Visual Studio Code Integration&lt;/h1&gt;

&lt;p&gt;Another nice Add-On that WSL2 brings is integration with &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;.  This means that the filesystem that VS Code sees is your WSL2 distro and you can open a terminal inside VS Code that works inside the distro too. For this just install the “Remote - WSL” plugin, then you can use the “Remote Explorer” button on the left hand side of the VS Code Window, to open a directory inside WSL.&lt;/p&gt;

&lt;p&gt;You can also get other VS Code plugins working inside the WSL environment, so things like the Docker and Kubernetes plugins can be installed and will work from that perspective too.&lt;/p&gt;

&lt;h1 id=&quot;host-filesystem-integration&quot;&gt;Host Filesystem Integration&lt;/h1&gt;

&lt;p&gt;In common with WSL1 the host’s filesystem is visible inside the distro. It’ll be mounted at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/mnt/c/&lt;/code&gt; so you can easily copy files into and out of the environment.&lt;/p&gt;

&lt;h1 id=&quot;customizing-our-distribution-for-container-work&quot;&gt;Customizing our Distribution for Container Work&lt;/h1&gt;

&lt;p&gt;Once we’re up and running we can customize our environment for the test type we’re using.  I’m using some ansible playbooks for this from &lt;a href=&quot;https://github.com/raesene/container_sec_workstation&quot;&gt;this repo&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Install ansible first.  If you’re using Ubuntu 20.04 you can just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt update &amp;amp;&amp;amp; apt install -y ansible&lt;/code&gt; to get that working&lt;/li&gt;
  &lt;li&gt;Then run the playbook &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ansible-playbook wsl_container_workstation.yml&lt;/code&gt; and it sets up the necessary tooling&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;using-our-wsl-distro-as-a-template&quot;&gt;Using our WSL distro as a template&lt;/h1&gt;

&lt;p&gt;Now that we’ve got the tooling we want installed, if we don’t want to re-run the ansible playbook for every test, we can export the rootfs for later use.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wsl --export baseubu c:\wsl\wslrootfs\containersec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we can create new instances based off this by importing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;containersec&lt;/code&gt; file we just created&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wsl --import test1 c:\wsl\wsldistros\test1\ c:\wsl\wslrootfs\containersec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and when we start it up, all our tools are in place :)&lt;/p&gt;

&lt;h1 id=&quot;cleaning-up&quot;&gt;Cleaning up&lt;/h1&gt;

&lt;p&gt;Once you’re finished with it, it can just be removed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsl.exe --unregister &amp;lt;Name&amp;gt;&lt;/code&gt;. This will delete the virtual disk file and leave everything nice and clean.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Overall I think that WSL2 along with Windows Terminal, Visual Studio Code, and Docker for Windows, can provide a very nice Linux based environment inside a host Windows OS. So for environments where you can’t, or don’t want to, run Linux as your base OS, it becomes fairly easy to set-up your tooling the way you want it to work.&lt;/p&gt;
</description>
				<pubDate>Sun, 31 May 2020 11:10:39 +0100</pubDate>
				<link>https://raesene.github.io/blog/2020/05/31/Custom_Pentest_Distributions_With_WSL2/</link>
				<guid isPermaLink="true">https://raesene.github.io/blog/2020/05/31/Custom_Pentest_Distributions_With_WSL2/</guid>
			</item>
		
	</channel>
</rss>
